<!DOCTYPE html>
<html lang="en">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fuel Price Analyzer</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling of the whole page */
        }
        #chart-tooltip {
            transition: opacity 0.1s ease-in-out;
        }
        /* Custom popup design */
        .leaflet-popup-content {
            margin: 0;
            width: 210px;
        }
        .leaflet-popup-content-wrapper {
            background-color: #2d3748; /* bg-gray-800 */
            color: #e2e8f0; /* text-gray-300 */
            border-radius: 0.375rem;
            border: 1px solid #4a5568;
            box-shadow: none;
        }
        .leaflet-popup-tip {
            background-color: #2d3748;
        }
        .leaflet-control-zoom-in, .leaflet-control-zoom-out {
            background-color: #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 0.5rem !important;
        }
        /* Scrollbar styling for sidebar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1a202c;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 10px;
            border: 2px solid #1a202c;
        }
        /* File dropzone styling */
        .dropzone-active {
            border-color: #3b82f6; /* blue-500 */
            background-color: #1f2937; /* gray-800 */
        }
        /* to hide arrows from the number input */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield; /* Firefox */
        }
        .custom-range-slider::-webkit-slider-runnable-track {
                width: 100%;
                height: 4px;
                cursor: pointer;
                background: #374151; /* Darker track: gray-700 */
                border-radius: 5px;
            }
        .custom-range-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                height: 16px;
                width: 16px;
                border-radius: 50%;
                background: #3b82f6; /* blue-500 */
                cursor: pointer;
                margin-top: -6px;
                border: 2px solid #6b7280; /* Subdued border: gray-500 */
            }
        /* Firefox specific styles */
        .custom-range-slider::-moz-range-track {
                width: 100%;
                height: 4px;
                cursor: pointer;
                background: #374151; /* Darker track: gray-700 */
                border-radius: 5px;
            }
        .custom-range-slider::-moz-range-thumb {
                height: 16px;
                width: 16px;
                border-radius: 50%;
                background: #3b82f6; /* blue-500 */
                cursor: pointer;
                border: 2px solid #6b7280; /* Subdued border: gray-500 */
            }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen">
    <div id="chart-tooltip" class="fixed hidden bg-gray-900 text-white text-sm rounded-md shadow-lg p-2 border border-gray-600 z-[1200]" style="pointer-events: none;"></div>

    <div id="upload-modal" class="fixed inset-0 bg-black bg-opacity-70 z-[1100] flex items-center justify-center hidden">
        <div id="modal-panel" class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4 transform transition-all opacity-0 -translate-y-4">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-bold">Upload Provider Data</h2>
                <button id="close-modal-btn" class="text-gray-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="space-y-6">
                <div>
                    <label for="provider-select-modal" class="block text-sm font-medium text-gray-300 mb-2">1. Select Fuel Provider</label>
                    <select id="provider-select-modal" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option>Pilot Flying J</option>
                        <option>Bobtail</option>
                        <option>Mudflap</option>
                        <option>Loves</option>
                        <option>Other</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">2. Choose CSV File</label>
                    <div id="dropzone" class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-gray-500 transition-colors">
                        <svg class="mx-auto h-12 w-12 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 7.5l4.5-4.5 4.5 4.5M21 16.5l-4.5 4.5-4.5-4.5M7.5 3v13.5M16.5 21V7.5" />
                        </svg>
                        <p class="mt-2 text-gray-400">
                            <span class="font-semibold text-blue-400">Click to select a file</span> or drag and drop
                        </p>
                        <p id="file-name-display" class="text-sm text-gray-500 mt-1"></p>
                        <input type="file" id="file-upload-modal" class="hidden" accept=".csv">
                        <p id="csv-helper-text" class="text-xs text-gray-500 mt-4 pt-4 border-t border-gray-700">
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification-container" class="fixed bottom-5 right-5 z-[1000] flex flex-col items-end space-y-2"></div>

    <header class="bg-gray-900 border-b border-gray-700 shadow-lg z-[1000]">
        <div class="w-full px-4 py-1 flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <label for="cluster-radius" class="block text-xs font-medium text-gray-300 whitespace-nowrap">Max Distance:</label>
                    <div class="relative">
                        <input id="cluster-radius" type="number" value="15" min="1" class="w-14 bg-transparent border-0 border-b-2 border-gray-500 text-center text-white pb-0.5 pr-5 text-sm focus:outline-none focus:ring-0 focus:border-blue-500 transition">
                        <span class="absolute right-0 top-0 h-full flex items-center text-xs text-gray-400 pointer-events-none">mi</span>
                    </div>
                </div>
                <div class="h-6 border-l border-gray-600"></div>
                <div class="flex items-center space-x-2">
                    <label class="block text-xs font-medium text-gray-300 whitespace-nowrap">State:</label>
                    <div id="state-dropdown-container" class="relative">
                        <input type="text" id="state-input" placeholder="All" class="w-16 bg-transparent border-0 border-b-2 border-gray-500 text-left text-white pb-0.5 text-sm focus:outline-none focus:ring-0 focus:border-blue-500 transition">
                        <div id="state-dropdown-panel" class="absolute hidden mt-2 w-full bg-gray-800 border border-gray-600 rounded-md shadow-lg z-20 max-h-60 overflow-y-auto custom-scrollbar">
                            </div>
                    </div>
                </div>
                <div class="flex items-center space-x-3 text-xs">
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="hide-unclustered" class="sr-only peer">
                        <div class="relative w-9 h-5 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600 peer-disabled:opacity-50"></div>
                        <span class="ms-1.5 font-medium text-gray-300">Hide Unpaired</span>
                    </label>
                    <label id="triads-only-container" class="inline-flex items-center cursor-pointer hidden">
                        <input type="checkbox" id="show-triads-only" class="sr-only peer" disabled>
                        <div class="relative w-9 h-5 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600 peer-disabled:opacity-50"></div>
                        <span class="ms-1.5 font-medium text-gray-300">Triads Only</span>
                    </label>
                    <label id="tetrads-only-container" class="inline-flex items-center cursor-pointer hidden">
                        <input type="checkbox" id="show-tetrads-only" class="sr-only peer" disabled>
                        <div class="relative w-9 h-5 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600 peer-disabled:opacity-50"></div>
                        <span class="ms-1.5 font-medium text-gray-300">Tetrads Only</span>
                    </label>
                </div>
            </div>

            <div class="flex items-center space-x-3">
                <div class="relative group cursor-pointer">
                    <div id="unpaired-counter" class="text-sm"></div>
                    <div id="unpaired-tooltip" class="absolute hidden group-hover:block top-full left-1/2 -translate-x-1/2 mt-1 w-max bg-gray-800 text-gray-300 text-xs rounded-md p-2 border border-gray-600 shadow-lg z-30">
                        </div>
                </div>
                <div class="h-6 border-l border-gray-600 stat-separator hidden"></div>
                <div id="paired-only-counter" class="text-sm"></div>
                <div class="h-6 border-l border-gray-600 stat-separator hidden"></div>
                <div id="pair-links-counter" class="text-sm"></div>
                <div class="h-6 border-l border-gray-600 stat-separator hidden"></div>
                <div id="triad-groups-counter" class="text-sm"></div>
                <div class="h-6 border-l border-gray-600 stat-separator hidden"></div>
                <div id="tetrad-groups-counter" class="text-sm"></div>
                <div class="h-6 border-l border-gray-600"></div>
                <div id="file-upload-section" class="flex items-center space-x-2 flex-nowrap">
                    <span class="text-xs text-gray-500 italic">No datasets loaded</span>
                </div>
                <div class="h-6 border-l border-gray-600"></div>
                <button id="open-modal-btn" class="flex items-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-3 text-xs rounded-md transition duration-300">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <!-- NEW: Modals for provider-specific options -->
    <div id="mudflap-product-modal" class="fixed inset-0 bg-black bg-opacity-70 z-[1200] flex items-center justify-center hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4 transform transition-all">
            <h2 class="text-xl font-bold mb-4">Select Mudflap Products</h2>
            <p class="text-sm text-gray-400 mb-4">Your file contains multiple products. Please select which ones to load.</p>
            <div id="mudflap-product-list" class="max-h-60 overflow-y-auto custom-scrollbar bg-gray-900 p-3 rounded-md border border-gray-700 space-y-2">
                <!-- Checkboxes will be injected here by JS -->
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="mudflap-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium">Cancel</button>
                <button id="mudflap-confirm-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium">Load Selected</button>
            </div>
        </div>
    </div>

    <div id="bobtail-choice-modal" class="fixed inset-0 bg-black bg-opacity-70 z-[1200] flex items-center justify-center hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4 transform transition-all">
            <h2 class="text-xl font-bold mb-4">Select Bobtail Price</h2>
            <p class="text-sm text-gray-400 mb-4">Which discounted price do you want to load?</p>
            <div class="space-y-3">
                <button id="bobtail-choice-regular" class="w-full text-left px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded-md transition-colors">
                    <div class="font-semibold">Regular Price Only</div>
                    <div class="text-xs text-gray-400">Use <code class="text-blue-400">DISCOUNT_PRICE</code>.</div>
                </button>
                <button id="bobtail-choice-large-only" class="w-full text-left px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded-md transition-colors">
                    <div class="font-semibold">Large Fleet Price Only</div>
                    <div class="text-xs text-gray-400">Use <code class="text-blue-400">LARGE_FLEET_DISCOUNT_PRICE</code>.</div>
                    <div class="text-xs text-gray-400 mt-1">Rows without a large fleet price will be <span class="font-semibold text-red-400">discarded</span>.</div>
                </button>
                <button id="bobtail-choice-fallback" class="w-full text-left px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded-md transition-colors">
                    <div class="font-semibold">Large Fleet (with Regular Fallback)</div>
                    <div class="text-xs text-gray-400">Use <code class="text-blue-400">LARGE_FLEET_DISCOUNT_PRICE</code> first.</div>
                    <div class="text-xs text-gray-400 mt-1">If large fleet price is not available, it will use the regular <code class="text-blue-400">DISCOUNT_PRICE</code>.</div>
                </button>
            </div>
            <div class="mt-6 flex justify-end">
                <button id="bobtail-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium">Cancel</button>
            </div>
        </div>
    </div>
    <!-- END of new modals -->

    <main class="flex-grow flex overflow-hidden">
        <div id="map" class="w-3/5 h-full bg-gray-800"></div>

        <aside class="w-2/5 bg-gray-900 h-full flex flex-col border-l border-gray-700">
            <div class="p-2 bg-gray-900 border-b border-gray-700 flex items-center justify-between space-x-4">
                
                <div class="flex items-center space-x-2">
                    <label for="analysis-metric-select" class="text-xs font-medium text-gray-300 whitespace-nowrap">Metric:</label>
                    <select id="analysis-metric-select" class="w-40 bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="discounted" selected>Discounted Price</option>
                        <option value="retail">Retail Price</option>
                        <option value="savings">Savings</option>
                    </select>
                </div>
            </div>
            
            <div id="infographics" class="flex-grow p-2 overflow-y-auto custom-scrollbar">
                <div id="info-placeholder" class="text-center text-gray-500 pt-10">
                    <svg class="mx-auto h-12 w-12 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2z" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-400">No Data</h3>
                    <p class="mt-1 text-sm text-gray-500">Upload CSV files to begin analysis.</p>
                </div>
                <div id="info-content" class="hidden space-y-3">
                    </div>
            </div>
        </aside>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- MAP INITIALIZATION ---
            const map = L.map('map', {
                center: [39.8283, -98.5795], // Center of the USA
                zoom: 5,
                zoomControl: false // Custom zoom control position
            });

            L.control.zoom({
                position: 'bottomright'
            }).addTo(map);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);
            
            // --- STATE MANAGEMENT ---
           const state = {
                    stationData: {}, // { "ProviderName": [station, station, ...] }
                    markers: L.markerClusterGroup({
                        iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount(); // Get the total number of stations in the cluster

                        let c = ' marker-cluster-';
                        if (count < 10) { c += 'small'; } 
                        else if (count < 100) { c += 'medium'; } 
                        else { c += 'large'; }
                        return new L.DivIcon({ html: '<div><span>' + count + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
                    },
                        maxClusterRadius: 80,
                        disableClusteringAtZoom: 12
                    }),
                    linesLayer: L.layerGroup(),
                    tempLinesLayer: L.layerGroup(), 
                    priceBracketLayer: L.layerGroup(), // <-- NEW: Layer for price bracket markers
                    hideUnclustered: false,
                    clusterRadius: 15,
                    showTriadsOnly: false,
                    showTetradsOnly: false,
                    analysisMetric: 'discounted',
                    competitiveFilter: 'all',
                    showLines: false, 
                    lineOpacity: 0.3,
                    selectedState: 'all',
                    showPriceBrackets: false, // <-- NEW: State for bracket toggle
                    priceBracketProvider: 'all' // <-- NEW: State for bracket provider dropdown
                };

                map.addLayer(state.markers);
                map.addLayer(state.linesLayer);
                map.addLayer(state.tempLinesLayer);
                map.addLayer(state.priceBracketLayer); // <-- NEW: Add layer to map (it's empty)

            map.on('click', () => {
                state.tempLinesLayer.clearLayers();
            });

            const lineControl = L.Control.extend({
                options: {
                    position: 'bottomleft'
                },
                onAdd: function (map) {
                    const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control-custom bg-gray-900/70 backdrop-blur-sm border border-gray-700 p-3 rounded-lg shadow-lg w-64 space-y-2');
                    
                    // <-- MODIFIED: Added HTML for Price Brackets -->
                    container.innerHTML = `
                        <div class="flex items-center justify-between">
                            <label for="show-lines-toggle" class="font-medium text-gray-200 text-sm">Links</label>
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="show-lines-toggle" class="sr-only peer">
                                <div class="relative w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                        <div id="opacity-slider-container" class="flex items-center space-x-2 transition-opacity">
                            <svg class="w-4 h-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 9.563C9 9.254 9.254 9 9.563 9h4.874c.31 0 .563.254.563.563v4.874c0 .31-.254.563-.563.563H9.564A.562.562 0 019 14.437V9.564z" stroke-dasharray="2 2" />
                            </svg>
                            <input type="range" id="opacity-slider" min="0.1" max="1" step="0.05" value="0.3" class="w-full h-1.5 rounded-lg appearance-none cursor-pointer custom-range-slider">
                            <svg class="w-4 h-4 text-gray-500" fill="currentColor" viewBox="0 0 24 24">
                               <path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2z" />
                            </svg>
                        </div>

                        <!-- NEW: Price Bracket Section -->
                        <div class="border-t border-gray-700 pt-2 mt-2 space-y-2">
                            <div class="flex items-center justify-between">
                                <label for="show-brackets-toggle" class="font-medium text-gray-200 text-sm">Price Brackets</label>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="show-brackets-toggle" class="sr-only peer">
                                    <div class="relative w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                </label>
                            </div>
                            <div id="bracket-controls-container" class="hidden space-y-2">
                                <select id="bracket-provider-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <!-- Options will be populated by JS -->
                                </select>
                                <div id="bracket-legend-container" class="text-xs text-gray-300 space-y-0.5">
                                    <!-- Legend will be populated by JS -->
                                </div>
                            </div>
                        </div>
                    `;
                    // <-- END OF MODIFICATION -->

                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.disableScrollPropagation(container);
                    
                    const sliderContainer = container.querySelector('#opacity-slider-container');
                    const slider = container.querySelector('#opacity-slider');
                    const toggle = container.querySelector('#show-lines-toggle');
                    
                    
                    const bracketToggle = container.querySelector('#show-brackets-toggle');
                    const bracketControls = container.querySelector('#bracket-controls-container');
                    const bracketSelect = container.querySelector('#bracket-provider-select');
                    const linksContainer = toggle.closest('.flex');
                    const bracketContainer = bracketToggle.closest('.flex');
                    

                    const updateSliderState = () => {
                        if (toggle.checked) {
                             sliderContainer.classList.remove('opacity-40', 'pointer-events-none');
                        } else {
                            sliderContainer.classList.add('opacity-40', 'pointer-events-none');
                        }
                    };

                    slider.addEventListener('input', (e) => {
                        state.lineOpacity = parseFloat(e.target.value);
                        applyVisibilityFilter(); 
                    });

                    toggle.addEventListener('change', (e) => {
                        state.showLines = e.target.checked;

                        if (state.showLines) {
                           
                            state.showPriceBrackets = false;
                            bracketToggle.checked = false;
                            bracketToggle.disabled = true;
                            bracketControls.classList.add('hidden');
                            bracketContainer.classList.add('opacity-50', 'pointer-events-none');
                            updatePriceBracketVisibility(); 
                        } else {
                           
                            bracketToggle.disabled = false;
                            bracketContainer.classList.remove('opacity-50', 'pointer-events-none');
                        }

                        state.tempLinesLayer.clearLayers();
                        updateSliderState();
                        updateLineVisibility(); 
                    });

                  
                    bracketToggle.addEventListener('change', (e) => {
                        state.showPriceBrackets = e.target.checked;
                        bracketControls.classList.toggle('hidden', !state.showPriceBrackets);

                        if (state.showPriceBrackets) {
                          
                            state.showLines = false;
                            toggle.checked = false;
                            toggle.disabled = true;
                            linksContainer.classList.add('opacity-50', 'pointer-events-none');
                            sliderContainer.classList.add('opacity-40', 'pointer-events-none');
                            updateLineVisibility();
                        } else {
                           
                            toggle.disabled = false;
                            linksContainer.classList.remove('opacity-50', 'pointer-events-none');
                            updateSliderState(); 
                        }

                        updatePriceBracketVisibility();
                    });

                    bracketSelect.addEventListener('change', (e) => {
                        state.priceBracketProvider = e.target.value;
                        if (state.showPriceBrackets) {
                            drawPriceBrackets(); // Redraw if the provider changes
                        }
                    });
                    // <-- END OF NEW LISTENERS -->

                    updateSliderState();

                    return container;
                }
            });
            
            map.addControl(new lineControl());

            // --- ICON CONFIGURATION ---
            const providerIcons = {
                'Bobtail': 'https://i.postimg.cc/8zyzSMgM/bobtail.png',
                'Pilot Flying J': 'https://i.postimg.cc/XvwvGJrR/pilot-logo.png',
                'Mudflap': 'https://i.postimg.cc/X74jBQV9/mudlap.png',
                'Loves': 'https://i.postimg.cc/5tw38yNH/LOVES-LOGO.png',
                'Other': 'https://i.postimg.cc/pXf9q7s0/default-logo.png'
            };


            const providerColors = { 
                                'Pilot Flying J': '#ef4444', /* Red */
                                'Bobtail': '#f97316',      /* Orange */
                                'Mudflap': '#22c55e',      /* Green */
                                'Loves': '#f59e0b',        /* Amber */
                                'TA': '#3b82f6',          /* Blue */
                                'Other': '#6b7280'        /* Gray */
                            };

                            const providerHeaderMaps = {
                                'Pilot Flying J': {
                                    station_name: null, // Will be hardcoded
                                    city: 'city',
                                    state: 'st',
                                    site: 'site', // <-- This is now the required key
                                    retail_price: 'retail price',
                                    discounted_price: 'your price',
                                    savings: 'savings total'
                                },
                                'Bobtail': {
                                    station_name: 'name',
                                    city: 'city',
                                    state: 'state',
                                    latitude: 'latitude',
                                    longitude: 'longitude',
                                    retail_price: 'retail_price',
                                    // These are special cases handled in processData
                                    discounted_price: 'discount_price',
                                    savings: 'savings',
                                    large_fleet_discount_price: 'large_fleet_discount_price',
                                    large_fleet_savings: 'large_fleet_savings'
                                },
                                'Mudflap': {
                                    station_name: 'truck_stop_name',
                                    city: 'city',
                                    state: 'state',
                                    latitude: 'latitude',
                                    longitude: 'longitude',
                                    retail_price: 'total_retail_price',
                                    discounted_price: 'personal_price',
                                    savings: 'discount_total',
                                    // Filters
                                    card_type: 'card_type',
                                    product_name: 'product_name'
                                },
                                'Loves': { // Assuming default until user provides
                                    station_name: 'station_name',
                                    city: 'city',
                                    state: 'state',
                                    latitude: 'latitude',
                                    longitude: 'longitude',
                                    retail_price: 'retail_price',
                                    discounted_price: 'discounted_price',
                                    savings: 'savings'
                                },
                                'Other': {
                                    station_name: 'station_name',
                                    city: 'city',
                                    state: 'state',
                                    latitude: 'latitude',
                                    longitude: 'longitude',
                                    retail_price: 'retail_price',
                                    discounted_price: 'discounted_price',
                                    savings: 'savings'
                                }
                            };

const pilotSiteMap = {
    '001': { lat: 41.1155, lon: -77.4777 },
    '002': { lat: 41.7644, lon: -80.9388 },
    '003': { lat: 41.1213, lon: -80.7781 },
    '004': { lat: 41.4646, lon: -82.0289 },
    '006': { lat: 40.0011, lon: -81.5833 },
    '008': { lat: 39.6385, lon: -82.9351 },
    '009': { lat: 39.5441, lon: -84.3411 },
    '011': { lat: 40.9765, lon: -80.6552 },
    '012': { lat: 41.5235, lon: -83.6708 },
    '013': { lat: 41.0573, lon: -81.8624 },
    '014': { lat: 40.2319, lon: -82.8465 },
    '015': { lat: 41.7212, lon: -83.5601 },
    '017': { lat: 42.2796, lon: -85.2536 },
    '021': { lat: 42.3087, lon: -83.8444 },
    '024': { lat: 41.9427, lon: -83.3708 },
    '026': { lat: 41.7454, lon: -83.7441 },
    '029': { lat: 41.7242, lon: -84.9358 },
    '030': { lat: 39.8153, lon: -85.7725 },
    '031': { lat: 41.5936, lon: -87.4589 },
    '034': { lat: 40.7588, lon: -87.1519 },
    '035': { lat: 41.6705, lon: -86.3986 },
    '037': { lat: 39.5807, lon: -86.1362 },
    '039': { lat: 41.4239, lon: -87.7954 },
    '040': { lat: 42.9004, lon: -87.9338 },
    '041': { lat: 38.0664, lon: -83.9213 },
    '043': { lat: 41.6192, lon: -90.7675 },
    '044': { lat: 38.9669, lon: -92.6841 },
    '047': { lat: 38.2045, lon: -84.5458 },
    '048': { lat: 37.5935, lon: -85.9008 },
    '049': { lat: 36.6669, lon: -87.4116 },
    '050': { lat: 38.4891, lon: -85.2536 },
    '051': { lat: 36.2163, lon: -82.8229 },
    '052': { lat: 36.0305, lon: -86.5815 },
    '053': { lat: 35.9691, lon: -87.7738 },
    '056': { lat: 35.4801, lon: -80.6276 },
    '057': { lat: 36.0792, lon: -79.2558 },
    '060': { lat: 33.3518, lon: -80.6976 },
    '062': { lat: 34.1565, lon: -79.7909 },
    '063': { lat: 34.6978, lon: -82.4431 },
    '066': { lat: 34.1481, lon: -83.7842 },
    '067': { lat: 34.2259, lon: -84.8427 },
    '068': { lat: 32.5028, lon: -82.9463 },
    '071': { lat: 32.1764, lon: -81.1668 },
    '075': { lat: 30.8524, lon: -88.0536 },
    '076': { lat: 33.1593, lon: -87.4332 },
    '077': { lat: 32.3551, lon: -90.2312 },
    '081': { lat: 40.9234, lon: -80.1417 },
    '087': { lat: 30.4795, lon: -81.6844 },
    '090': { lat: 27.4278, lon: -80.4285 },
    '091': { lat: 29.9961, lon: -81.5645 },
    '092': { lat: 29.0494, lon: -82.1643 },
    '094': { lat: 26.9859, lon: -81.9427 },
    '095': { lat: 28.8711, lon: -82.0388 },
    '096': { lat: 27.3821, lon: -80.8291 },
    '097': { lat: 39.8788, lon: -84.1868 },
    '114': { lat: 35.9863, lon: -84.9754 },
    '118': { lat: 34.6291, lon: -92.5193 },
    '130': { lat: 41.2384, lon: -81.6052 },
    '131': { lat: 41.0336, lon: -93.7941 },
    '133': { lat: 43.2185, lon: -121.7871 },
    '134': { lat: 45.5393, lon: -94.1368 },
    '137': { lat: 41.4395, lon: -122.3792 },
    '141': { lat: 41.2981, lon: -110.9631 },
    '144': { lat: 33.3512, lon: -82.0289 },
    '145': { lat: 36.1969, lon: -94.1561 },
    '146': { lat: 42.5413, lon: -73.7667 },
    '147': { lat: 40.7381, lon: -114.0628 },
    '150': { lat: 39.6738, lon: -77.8288 },
    '151': { lat: 46.8507, lon: -122.9095 },
    '154': { lat: 35.6171, lon: -119.6865 },
    '156': { lat: 37.2389, lon: -87.4722 },
    '157': { lat: 33.1028, lon: -95.6416 },
    '159': { lat: 37.4565, lon: -77.0392 },
    '163': { lat: 32.3323, lon: -108.7077 },
    '164': { lat: 43.8378, lon: -90.1384 },
    '165': { lat: 39.1352, lon: -88.5441 },
    '167': { lat: 37.8385, lon: -94.3242 },
    '168': { lat: 38.8925, lon: -121.9368 },
    '171': { lat: 40.1235, lon: -87.7779 },
    '174': { lat: 34.4925, lon: -89.0194 },
    '179': { lat: 39.6828, lon: -77.7852 },
    '180': { lat: 35.2155, lon: -111.8398 },
    '190': { lat: 40.7021, lon: -74.9602 },
    '192': { lat: 31.4398, lon: -83.4831 },
    '195': { lat: 45.4215, lon: -121.1645 },
    '196': { lat: 35.4268, lon: -94.5065 },
    '198': { lat: 41.3571, lon: -86.3039 },
    '199': { lat: 32.5422, lon: -93.5939 },
    '200': { lat: 35.0093, lon: -117.6163 },
    '206': { lat: 32.7845, lon: -97.7942 },
    '208': { lat: 38.4802, lon: -90.7631 },
    '209': { lat: 31.0425, lon: -104.8093 },
    '210': { lat: 41.0772, lon: -74.1565 },
    '211': { lat: 34.5244, lon: -114.3615 },
    '213': { lat: 39.9575, lon: -82.8532 },
    '219': { lat: 36.0125, lon: -83.7843 },
    '222': { lat: 42.1098, lon: -72.0833 },
    '231': { lat: 36.9535, lon: -84.0784 },
    '232': { lat: 44.0275, lon: -116.9405 },
    '233': { lat: 43.4326, lon: -123.3035 },
    '234': { lat: 30.6974, lon: -95.5562 },
    '236': { lat: 41.4589, lon: -88.2676 },
    '237': { lat: 36.7028, lon: -121.6119 },
    '238': { lat: 40.7584, lon: -95.8087 },
    '239': { lat: 40.8251, lon: -83.2559 },
    '242': { lat: 39.5186, lon: -85.7651 },
    '243': { lat: 38.4069, lon: -81.8214 },
    '247': { lat: 40.0213, lon: -86.8971 },
    '249': { lat: 38.7188, lon: -89.8863 },
    '252': { lat: 39.3855, lon: -94.3644 },
    '253': { lat: 39.7118, lon: -75.4641 },
    '255': { lat: 41.2059, lon: -73.0785 },
    '256': { lat: 36.6322, lon: -79.4001 },
    '257': { lat: 31.8688, lon: -102.1009 },
    '259': { lat: 35.7592, lon: -95.3359 },
    '260': { lat: 31.5991, lon: -84.1678 },
    '261': { lat: 33.5042, lon: -89.7214 },
    '267': { lat: 32.6288, lon: -83.7548 },
    '268': { lat: 41.6192, lon: -90.7675 },
    '270': { lat: 35.8893, lon: -84.1669 },
    '271': { lat: 41.5835, lon: -87.3015 },
    '274': { lat: 30.2882, lon: -91.9056 },
    '275': { lat: 35.3789, lon: -80.8529 },
    '279': { lat: 31.4721, lon: -110.9995 },
    '280': { lat: 40.6728, lon: -75.0681 },
    '281': { lat: 41.1441, lon: -80.7258 },
    '282': { lat: 34.8471, lon: -117.0789 },
    '284': { lat: 41.9427, lon: -83.3708 },
    '285': { lat: 39.9168, lon: -82.4695 },
    '286': { lat: 39.7545, lon: -84.6369 },
    '287': { lat: 40.9781, lon: -81.9565 },
    '289': { lat: 42.5358, lon: -89.0279 },
    '293': { lat: 29.2888, lon: -82.2642 },
    '296': { lat: 42.3087, lon: -83.8444 },
    '298': { lat: 41.0118, lon: -76.0142 },
    '299': { lat: 39.0489, lon: -86.5393 },
    '300': { lat: 30.5098, lon: -90.4132 },
    '302': { lat: 30.5691, lon: -88.1889 },
    '303': { lat: 41.4239, lon: -84.1265 },
    '304': { lat: 41.0664, lon: -84.9753 },
    '305': { lat: 35.3411, lon: -107.7289 },
    '306': { lat: 29.4589, lon: -98.3752 },
    '307': { lat: 33.9112, lon: -116.5141 },
    '308': { lat: 41.3005, lon: -105.5908 },
    '309': { lat: 39.7891, lon: -81.5273 },
    '310': { lat: 34.9298, lon: -82.1287 },
    '311': { lat: 42.0465, lon: -80.0868 },
    '312': { lat: 33.9961, lon: -85.2711 },
    '313': { lat: 38.6186, lon: -90.1342 },
    '317': { lat: 37.0421, lon: -94.5029 },
    '321': { lat: 38.8302, lon: -84.6291 },
    '322': { lat: 42.3831, lon: -77.3015 },
    '324': { lat: 42.8596, lon: -88.0121 },
    '328': { lat: 33.6631, lon: -114.2384 },
    '329': { lat: 41.2425, lon: -95.8239 },
    '330': { lat: 29.7425, lon: -98.0818 },
    '331': { lat: 33.7226, lon: -84.5429 },
    '332': { lat: 34.8213, lon: -92.1528 },
    '335': { lat: 32.4935, lon: -91.7588 },
    '336': { lat: 41.1188, lon: -78.7909 },
    '337': { lat: 34.1565, lon: -79.7909 },
    '338': { lat: 33.9555, lon: -81.0822 },
    '340': { lat: 39.6015, lon: -119.2273 },
    '341': { lat: 36.1969, lon: -115.1275 },
    '343': { lat: 32.5539, lon: -116.9698 },
    '346': { lat: 34.2052, lon: -80.6865 },
    '348': { lat: 40.1384, lon: -80.0076 },
    '350': { lat: 43.1501, lon: -115.6888 },
    '352': { lat: 26.5841, lon: -81.8741 },
    '353': { lat: 38.2045, lon: -84.5458 },
    '354': { lat: 38.2144, lon: -85.3421 },
    '356': { lat: 38.0356, lon: -85.6791 },
    '358': { lat: 37.0628, lon: -88.7459 },
    '360': { lat: 41.136886, lon: -83.660542 },
    '365': { lat: 36.9142, lon: -120.1068 },
    '366': { lat: 35.5925, lon: -88.8248 },
    '367': { lat: 33.0501, lon: -96.2509 },
    '368': { lat: 39.8408, lon: -88.8833 },
    '370': { lat: 41.2965, lon: -75.7938 },
    '372': { lat: 34.5029, lon: -118.6255 },
    '373': { lat: 41.6465, lon: -93.7915 },
    '374': { lat: 30.7718, lon: -85.1843 },
    '375': { lat: 29.9928, lon: -95.4215 },
    '377': { lat: 27.6181, lon: -99.5583 },
    '380': { lat: 43.1095, lon: -76.2238 },
    '381': { lat: 34.4981, lon: -117.3208 },
    '384': { lat: 37.2885, lon: -77.4243 },
    '385': { lat: 37.8872, lon: -93.6195 },
    '386': { lat: 44.9545, lon: -123.0883 },
    '388': { lat: 32.3361, lon: -88.7491 },
    '390': { lat: 45.7766, lon: -119.2215 },
    '391': { lat: 42.3831, lon: -122.9008 },
    '393': { lat: 35.4851, lon: -82.9782 },
    '394': { lat: 41.5208, lon: -74.0792 },
    '396': { lat: 38.1818, lon: -79.0569 },
    '399': { lat: 37.8541, lon: -85.7335 },
    '402': { lat: 41.1396, lon: -104.7088 },
    '404': { lat: 35.8193, lon: -86.3985 },
    '406': { lat: 35.3942, lon: -86.8389 },
    '407': { lat: 43.1611, lon: -93.3512 },
    '408': { lat: 39.6918, lon: -79.1678 },
    '409': { lat: 36.0371, lon: -87.3758 },
    '411': { lat: 36.1915, lon: -86.3151 },
    '412': { lat: 36.1265, lon: -83.2801 },
    '415': { lat: 34.7865, lon: -85.5036 },
    '416': { lat: 31.9705, lon: -83.7661 },
    '417': { lat: 33.7431, lon: -85.0345 },
    '420': { lat: 33.5658, lon: -83.4502 },
    '421': { lat: 34.8012, lon: -84.9221 },
    '422': { lat: 33.4005, lon: -84.7791 },
    '424': { lat: 29.2888, lon: -82.2039 },
    '425': { lat: 30.4955, lon: -84.4532 },
    '428': { lat: 32.5201, lon: -92.1469 },
    '429': { lat: 35.1508, lon: -90.2033 },
    '430': { lat: 35.2536, lon: -93.1258 },
    '431': { lat: 30.0898, lon: -93.8329 },
    '432': { lat: 31.5901, lon: -97.1082 },
    '433': { lat: 32.6685, lon: -96.7571 },
    '434': { lat: 32.9931, lon: -97.3201 },
    '435': { lat: 31.9961, lon: -106.6212 },
    '436': { lat: 35.1855, lon: -101.7335 },
    '437': { lat: 36.7828, lon: -84.1689 },
    '438': { lat: 36.7095, lon: -86.5759 },
    '439': { lat: 36.6669, lon: -87.4116 },
    '440': { lat: 38.4891, lon: -85.2536 },
    '441': { lat: 34.6401, lon: -86.9535 },
    '442': { lat: 36.2335, lon: -89.7712 },
    '443': { lat: 39.0988, lon: -93.7176 },
    '444': { lat: 39.5255, lon: -87.1422 },
    '445': { lat: 41.6025, lon: -87.0425 },
    '446': { lat: 40.1558, lon: -85.5861 },
    '447': { lat: 38.1932, lon: -87.5583 },
    '448': { lat: 41.2915, lon: -87.1822 },
    '449': { lat: 40.0298, lon: -81.0505 },
    '454': { lat: 39.9056, lon: -83.4385 },
    '455': { lat: 40.4005, lon: -82.8051 },
    '457': { lat: 40.8242, lon: -83.9515 },
    '458': { lat: 32.8035, lon: -111.5365 },
    '459': { lat: 33.4578, lon: -112.2691 },
    '460': { lat: 35.4575, lon: -97.6908 },
    '467': { lat: 29.6085, lon: -98.4552 },
    '468': { lat: 40.7628, lon: -87.9901 },
    '469': { lat: 40.7681, lon: -81.3938 },
    '470': { lat: 45.0068, lon: -92.5445 },
    '471': { lat: 28.1751, lon: -81.6156 },
    '472': { lat: 29.4935, lon: -95.9128 },
    '473': { lat: 41.4288, lon: -88.2215 },
    '474': { lat: 38.6948, lon: -80.6865 },
    '475': { lat: 35.0028, lon: -106.0245 },
    '476': { lat: 41.1788, lon: -90.3168 },
    '477': { lat: 33.3491, lon: -96.5801 },
    '478': { lat: 38.1888, lon: -86.3533 },
    '481': { lat: 35.1205, lon: -84.9015 },
    '482': { lat: 38.3101, lon: -88.9745 },
    '483': { lat: 41.3655, lon: -88.4091 },
    '485': { lat: 40.9691, lon: -117.7412 },
    '486': { lat: 32.3215, lon: -95.2755 },
    '488': { lat: 28.4312, lon: -99.2435 },
    '489': { lat: 47.8865, lon: -97.0945 },
    '491': { lat: 38.4239, lon: -78.8778 },
    '492': { lat: 34.1035, lon: -93.0645 },
    '493': { lat: 33.1705, lon: -80.5901 },
    '494': { lat: 42.7661, lon: -74.0328 },
    '495': { lat: 41.7335, lon: -92.4411 },
    '497': { lat: 33.5801, lon: -86.1368 },
    '498': { lat: 34.3705, lon: -96.1265 },
    '500': { lat: 30.5601, lon: -82.9515 },
    '503': { lat: 39.6385, lon: -79.9928 },
    '504': { lat: 42.2618, lon: -121.8035 },
    '507': { lat: 30.8142, lon: -97.6169 },
    '509': { lat: 40.9158, lon: -112.5518 },
    '510': { lat: 39.2435, lon: -112.1105 },
    '511': { lat: 46.8188, lon: -100.9501 },
    '513': { lat: 35.7766, lon: -115.3345 },
    '514': { lat: 40.1388, lon: -89.3676 },
    '517': { lat: 40.3701, lon: -77.0505 },
    '518': { lat: 40.4435, lon: -76.2201 },
    '549': { lat: 36.4801, lon: -80.5895 },
    '550': { lat: 48.2045, lon: -101.3208 },
    '551': { lat: 32.3785, lon: -98.9601 },
    '552': { lat: 39.3901, lon: -84.2255 },
    '553': { lat: 30.8872, lon: -102.8208 },
    '554': { lat: 28.3301, lon: -98.1065 },
    '557': { lat: 32.7301, lon: -103.2108 },
    '559': { lat: 32.2285, lon: -101.4501 },
    '568': { lat: 29.2561, lon: -98.6308 },
    '571': { lat: 36.9061, lon: -89.3508 },
    '572': { lat: 42.4835, lon: -93.5308 },
    '573': { lat: 30.1061, lon: -96.0608 },
    '575': { lat: 30.7585, lon: -81.5795 },
    '576': { lat: 44.4485, lon: -93.2108 },
    '580': { lat: 31.7901, lon: -102.3908 },
    '581': { lat: 44.8001, lon: -93.0508 },
    '583': { lat: 48.8472, lon: -122.5855 },
    '584': { lat: 45.2425, lon: -122.7561 },
    '586': { lat: 30.4578, lon: -88.5422 },
    '590': { lat: 45.8672, lon: -95.4422 },
    '592': { lat: 39.0915, lon: -108.5555 },
    '593': { lat: 32.2385, lon: -110.9901 },
    '594': { lat: 42.4785, lon: -96.3555 },
    '595': { lat: 37.7315, lon: -88.9595 },
    '596': { lat: 42.9735, lon: -82.5595 },
    '597': { lat: 39.3361, lon: -82.9595 },
    '599': { lat: 43.8872, lon: -100.7108 },
    '601': { lat: 33.3285, lon: -86.9901 },
    '602': { lat: 33.5601, lon: -86.7355 },
    '603': { lat: 31.2595, lon: -85.4422 },
    '604': { lat: 32.2535, lon: -86.4108 },
    '605': { lat: 35.2785, lon: -93.0888 },
    '606': { lat: 33.4872, lon: -94.0055 },
    '607': { lat: 35.1322, lon: -90.1472 },
    '608': { lat: 33.6061, lon: -114.5208 },
    '609': { lat: 32.8122, lon: -111.6055 },
    '610': { lat: 35.1972, lon: -114.0055 },
    '611': { lat: 33.4561, lon: -112.2208 },
    '612': { lat: 35.0301, lon: -110.7208 },
    '613': { lat: 35.3372, lon: -119.0355 },
    '614': { lat: 34.8471, lon: -117.0789 },
    '616': { lat: 34.8215, lon: -118.9401 },
    '617': { lat: 38.1272, lon: -121.3155 },
    '618': { lat: 37.7561, lon: -121.1055 },
    '619': { lat: 39.7601, lon: -104.7555 },
    '620': { lat: 40.1501, lon: -79.7408 },
    '621': { lat: 39.2622, lon: -103.6708 },
    '622': { lat: 27.4872, lon: -80.3355 },
    '623': { lat: 30.5895, lon: -84.6055 },
    '624': { lat: 28.4685, lon: -82.2108 },
    '625': { lat: 27.9945, lon: -82.3855 },
    '626': { lat: 30.0761, lon: -81.4855 },
    '627': { lat: 31.2185, lon: -81.5208 },
    '628': { lat: 34.3361, lon: -83.2408 },
    '630': { lat: 33.3035, lon: -83.9855 },
    '631': { lat: 30.6861, lon: -83.1355 },
    '632': { lat: 34.5801, lon: -84.9455 },
    '633': { lat: 33.6161, lon: -83.0608 },
    '634': { lat: 33.7431, lon: -85.0345 },
    '636': { lat: 41.6501, lon: -90.5755 },
    '637': { lat: 42.4772, lon: -92.2855 },
    '638': { lat: 43.6501, lon: -116.6555 },
    '639': { lat: 47.7122, lon: -116.9208 },
    '640': { lat: 42.6072, lon: -114.4208 },
    '641': { lat: 42.6595, lon: -112.1955 },
    '642': { lat: 38.6186, lon: -90.1342 },
    '643': { lat: 39.1335, lon: -88.5508 },
    '644': { lat: 41.3622, lon: -89.0755 },
    '645': { lat: 38.7245, lon: -90.1055 },
    '646': { lat: 42.4835, lon: -89.0408 },
    '647': { lat: 38.1932, lon: -87.5583 },
    '649': { lat: 39.7835, lon: -86.0355 },
    '650': { lat: 41.5645, lon: -87.2608 },
    '652': { lat: 40.0401, lon: -86.4955 },
    '653': { lat: 41.3001, lon: -87.4108 },
    '655': { lat: 39.8272, lon: -85.4355 },
    '656': { lat: 39.5801, lon: -86.1308 },
    '657': { lat: 37.7685, lon: -99.8855 },
    '658': { lat: 38.3972, lon: -96.2208 },
    '659': { lat: 38.8745, lon: -97.6155 },
    '660': { lat: 38.3845, lon: -82.6355 },
    '661': { lat: 36.7245, lon: -86.5408 },
    '662': { lat: 36.6669, lon: -87.4116 },
    '663': { lat: 38.1272, lon: -85.1108 },
    '664': { lat: 38.8685, lon: -84.6155 },
    '665': { lat: 32.4401, lon: -93.9408 },
    '666': { lat: 42.0961, lon: -86.4255 },
    '667': { lat: 42.7685, lon: -84.6855 },
    '668': { lat: 43.3445, lon: -83.9408 },
    '669': { lat: 37.0421, lon: -94.5029 },
    '671': { lat: 36.7861, lon: -89.5855 },
    '672': { lat: 38.7185, lon: -94.4608 },
    '673': { lat: 38.2245, lon: -91.1608 },
    '674': { lat: 38.8285, lon: -91.1408 },
    '675': { lat: 40.3945, lon: -91.5908 },
    '676': { lat: 30.4435, lon: -89.1755 },
    '677': { lat: 34.9601, lon: -89.7908 },
    '678': { lat: 32.2745, lon: -90.1355 },
    '682': { lat: 36.0501, lon: -79.3755 },
    '683': { lat: 35.5872, lon: -78.1355 },
    '684': { lat: 46.9185, lon: -104.0008 },
    '685': { lat: 46.8372, lon: -96.8408 },
    '686': { lat: 41.1461, lon: -96.2608 },
    '687': { lat: 41.1245, lon: -100.7655 },
    '688': { lat: 39.7118, lon: -75.4641 },
    '689': { lat: 35.1761, lon: -106.6208 },
    '690': { lat: 32.3323, lon: -108.7077 },
    '691': { lat: 35.1761, lon: -103.6955 },
    '692': { lat: 41.1122, lon: -114.9608 },
    '693': { lat: 42.9861, lon: -78.4108 },
    '694': { lat: 41.7644, lon: -80.9388 },
    '695': { lat: 40.8242, lon: -83.9515 },
    '696': { lat: 40.2319, lon: -82.8465 },
    '697': { lat: 41.1835, lon: -80.5708 },
    '698': { lat: 39.5585, lon: -83.4555 },
    '699': { lat: 39.9001, lon: -82.5208 },
    '700': { lat: 41.2384, lon: -81.6052 },
    '701': { lat: 34.1945, lon: -97.1608 },
    '702': { lat: 35.4845, lon: -95.5208 },
    '703': { lat: 35.4575, lon: -97.6908 },
    '704': { lat: 35.6535, lon: -97.4608 },
    '705': { lat: 35.3061, lon: -99.6355 },
    '706': { lat: 36.1601, lon: -95.8355 },
    '707': { lat: 41.1572, lon: -79.0808 },
    '708': { lat: 40.2185, lon: -77.1655 },
    '709': { lat: 41.1155, lon: -77.4777 },
    '710': { lat: 41.8761, lon: -75.7208 },
    '711': { lat: 35.1322, lon: -81.4908 },
    '712': { lat: 33.9545, lon: -80.9355 },
    '714': { lat: 34.9801, lon: -81.0108 },
    '716': { lat: 43.5972, lon: -96.7008 },
    '720': { lat: 35.9861, lon: -87.1208 },
    '722': { lat: 35.8893, lon: -84.1669 },
    '723': { lat: 35.1855, lon: -101.7335 },
    '725': { lat: 29.7745, lon: -94.9708 },
    '726': { lat: 32.6685, lon: -96.7571 },
    '727': { lat: 26.3545, lon: -98.1508 },
    '728': { lat: 31.7645, lon: -106.2908 },
    '729': { lat: 29.9928, lon: -95.4215 },
    '730': { lat: 27.6181, lon: -99.5583 },
    '733': { lat: 33.5945, lon: -101.8508 },
    '734': { lat: 30.1501, lon: -95.2108 },
    '735': { lat: 30.0898, lon: -93.8329 },
    '736': { lat: 31.4061, lon: -103.5008 },
    '737': { lat: 29.4589, lon: -98.3752 },
    '738': { lat: 32.4201, lon: -99.7808 },
    '739': { lat: 31.5901, lon: -97.1082 },
    '740': { lat: 29.7685, lon: -95.9708 },
    '741': { lat: 33.9122, lon: -98.4855 },
    '742': { lat: 40.5645, lon: -112.2908 },
    '743': { lat: 39.7361, lon: -111.8355 },
    '744': { lat: 41.2401, lon: -112.0008 },
    '746': { lat: 40.7245, lon: -111.9208 },
    '747': { lat: 40.1545, lon: -111.6408 },
    '748': { lat: 41.4161, lon: -112.0408 },
    '749': { lat: 37.9361, lon: -77.4708 },
    '750': { lat: 36.9545, lon: -80.9355 },
    '752': { lat: 39.1501, lon: -78.1908 },
    '754': { lat: 36.9545, lon: -81.0655 },
    '756': { lat: 44.2961, lon: -90.8355 },
    '758': { lat: 42.8585, lon: -106.2655 },
    '759': { lat: 41.1396, lon: -104.7088 },
    '760': { lat: 42.0801, lon: -110.9455 },
    '761': { lat: 41.2981, lon: -110.9631 },
    '762': { lat: 44.2861, lon: -105.4755 },
    '763': { lat: 41.8022, lon: -107.2308 },
    '764': { lat: 41.5761, lon: -109.2308 },
    '765': { lat: 33.8322, lon: -116.4208 },
    '768': { lat: 39.1245, lon: -94.5155 },
    '770': { lat: 40.9691, lon: -117.7412 },
    '772': { lat: 40.8061, lon: -111.9208 },
    '773': { lat: 38.7485, lon: -112.0855 },
    '774': { lat: 41.9722, lon: -112.7208 },
    '775': { lat: 37.0761, lon: -113.5708 },
    '784': { lat: 39.6101, lon: -75.9208 },
    '874': { lat: 25.8822, lon: -80.3208 },
    '875': { lat: 39.6201, lon: -75.8455 },
    '876': { lat: 37.9545, lon: -77.4855 },
    '879': { lat: 38.6201, lon: -121.5508 },
    '883': { lat: 32.5845, lon: -95.8455 },
    '887': { lat: 32.6985, lon: -100.9108 },
    '888': { lat: 34.5501, lon: -101.7608 },
    '889': { lat: 38.3022, lon: -88.9755 },
    '890': { lat: 37.0545, lon: -88.1108 },
    '891': { lat: 40.8901, lon: -74.6708 },
    '892': { lat: 38.9985, lon: -110.1355 },
    '893': { lat: 41.4901, lon: -95.3355 },
    '894': { lat: 28.7022, lon: -100.4855 },
    '895': { lat: 42.1422, lon: -83.2508 },
    '896': { lat: 43.1461, lon: -71.5508 },
    '897': { lat: 25.9322, lon: -80.2455 },
    '898': { lat: 36.6861, lon: -77.5855 },
    '899': { lat: 36.7461, lon: -78.1308 },
    '900': { lat: 35.3122, lon: -78.6008 },
    '902': { lat: 40.9161, lon: -98.3908 },
    '903': { lat: 38.8685, lon: -97.6155 },
    '904': { lat: 41.0501, lon: -102.0708 },
    '905': { lat: 46.8822, lon: -113.8855 },
    '906': { lat: 45.6422, lon: -109.2455 },
    '907': { lat: 46.3901, lon: -105.8408 },
    '908': { lat: 46.0022, lon: -112.6355 },
    '909': { lat: 48.5061, lon: -111.8608 },
    '910': { lat: 45.8945, lon: -111.5508 },
    '911': { lat: 47.1945, lon: -114.8855 },
    '912': { lat: 40.8322, lon: -98.6108 },
    '913': { lat: 41.6501, lon: -93.4508 },
    '914': { lat: 47.0022, lon: -114.0708 },
    '915': { lat: 45.7585, lon: -108.6208 },
    '916': { lat: 46.7461, lon: -114.0908 },
    '917': { lat: 47.4861, lon: -111.2908 },
    '918': { lat: 44.1061, lon: -103.2208 },
    '920': { lat: 39.3822, lon: -101.0508 },
    '922': { lat: 48.3685, lon: -114.1708 },
    '923': { lat: 45.7585, lon: -108.6208 },
    '924': { lat: 46.0022, lon: -112.6355 },
    '931': { lat: 44.1061, lon: -103.2208 },
    '934': { lat: 45.3022, lon: -118.0908 },
    '966': { lat: 40.6422, lon: -116.9208 },
    '967': { lat: 47.6185, lon: -117.5208 },
    '1001': { lat: 31.1901, lon: -101.4508 },
    '1003': { lat: 34.4361, lon: -100.2208 },
    '1004': { lat: 36.6861, lon: -97.3008 },
    '1005': { lat: 39.6061, lon: -119.2408 },
    '1006': { lat: 29.8022, lon: -99.7808 },
    '1009': { lat: 34.0101, lon: -117.4808 },
    '1012': { lat: 40.9822, lon: -91.5455 },
    '1013': { lat: 45.7545, lon: -111.2008 },
    '1014': { lat: 47.1145, lon: -104.7308 },
    '1015': { lat: 47.6822, lon: -104.1608 },
    '1017': { lat: 37.8061, lon: -121.3008 },
    '1019': { lat: 39.7361, lon: -122.1808 },
    '1021': { lat: 42.7501, lon: -86.0108 },
    '1023': { lat: 31.3622, lon: -94.7308 },
    '1024': { lat: 41.5222, lon: -88.1308 },
    '1025': { lat: 29.7901, lon: -95.1008 },
    '1027': { lat: 35.2422, lon: -102.4408 },
    '1028': { lat: 31.4645, lon: -96.0508 },
    '1030': { lat: 41.6701, lon: -87.7355 },
    '1033': { lat: 31.8461, lon: -102.1008 },
    '1041': { lat: 41.9061, lon: -88.1108 },
    '1042': { lat: 41.7061, lon: -87.8055 },
    '1043': { lat: 43.4145, lon: -112.0108 },
    '1046': { lat: 26.6785, lon: -80.7208 },
    '1047': { lat: 30.4795, lon: -81.6844 },
    '1049': { lat: 36.7322, lon: -76.6108 },
    '1051': { lat: 30.2261, lon: -93.0108 },
    '1054': { lat: 29.9861, lon: -97.8108 },
    '1056': { lat: 41.5601, lon: -84.7708 },
    '1057': { lat: 29.6745, lon: -95.1708 },
    '1058': { lat: 29.8022, lon: -82.1708 },
    '1059': { lat: 29.6861, lon: -96.9108 },
    '1061': { lat: 37.1745, lon: -93.3608 },
    '1063': { lat: 35.6945, lon: -82.0108 },
    '1068': { lat: 33.0222, lon: -80.2608 },
    '1070': { lat: 34.9422, lon: -104.7108 },
    '1071': { lat: 36.0822, lon: -119.3408 },
    '1080': { lat: 37.4585, lon: -121.1508 },
    '1082': { lat: 32.8861, lon: -79.9908 },
    '1083': { lat: 36.3461, lon: -102.0708 },
    '1086': { lat: 40.5061, lon: -85.6908 },
    '1092': { lat: 41.9461, lon: -91.6808 },
    '1094': { lat: 35.1322, lon: -118.4808 },
    '1096': { lat: 28.3945, lon: -80.7408 },
    '1098': { lat: 40.7185, lon: -74.1208 },
    '1103': { lat: 48.1461, lon: -122.1508 },
    '1105': { lat: 30.9501, lon: -92.2008 },
    '1106': { lat: 35.0501, lon: -106.7208 },
    '1110': { lat: 38.7945, lon: -104.7508 },
    '1114': { lat: 41.9901, lon: -87.9308 },
    '1117': { lat: 41.0945, lon: -86.2208 },
    '1118': { lat: 34.4361, lon: -103.2008 },
    '1126': { lat: 39.1945, lon: -94.4808 },
    '1128': { lat: 27.9145, lon: -81.8408 },
    '1132': { lat: 32.9785, lon: -115.5408 },
    '1134': { lat: 31.8361, lon: -103.9008 },
    '1135': { lat: 27.2261, lon: -98.1408 },
    '1140': { lat: 33.0545, lon: -97.4708 },
    '1143': { lat: 31.8145, lon: -102.4908 },
    '1145': { lat: 31.8861, lon: -102.1708 },
    '1146': { lat: 31.4022, lon: -103.5208 },
    '1147': { lat: 31.8461, lon: -103.0908 },
    '1161': { lat: 31.7822, lon: -102.4208 },
    '1163': { lat: 41.1785, lon: -79.8008 },
    '1165': { lat: 32.1022, lon: -103.1908 },
    '1169': { lat: 46.9622, lon: -122.8808 },
    '1171': { lat: 36.8061, lon: -114.0808 },
    '1173': { lat: 47.2422, lon: -122.3908 },
    '1174': { lat: 39.4022, lon: -87.7008 },
    '1175': { lat: 34.4261, lon: -112.2208 },
    '1177': { lat: 34.0322, lon: -117.4408 },
    '1178': { lat: 32.2385, lon: -110.9901 },
    '1179': { lat: 31.3545, lon: -110.9508 },
    '1180': { lat: 33.4545, lon: -112.9108 },
    '1181': { lat: 41.9145, lon: -89.0408 },
    '1185': { lat: 34.9361, lon: -114.2808 },
    '1192': { lat: 33.7661, lon: -112.5408 },
    '1193': { lat: 34.7361, lon: -113.6108 },
    '1194': { lat: 33.4261, lon: -112.2008 },
    '1195': { lat: 46.9745, lon: -120.5408 },
    '1205': { lat: 31.5822, lon: -102.8708 },
    '1206': { lat: 31.8622, lon: -103.0908 },
    '1207': { lat: 31.5822, lon: -102.8708 },
    '1208': { lat: 32.5585, lon: -114.5408 },
    '1209': { lat: 31.8461, lon: -102.1008 },
    '1211': { lat: 32.3185, lon: -102.5308 },
    '1212': { lat: 33.6061, lon: -113.6108 },
    '1219': { lat: 38.9861, lon: -89.1108 },
    '1225': { lat: 38.5661, lon: -89.8108 },
    '1227': { lat: 31.5301, lon: -103.1208 },
    '1234': { lat: 35.8661, lon: -114.6508 },
    '1235': { lat: 32.6945, lon: -113.9608 },
    '1243': { lat: 32.9461, lon: -112.7308 },
    '1247': { lat: 33.4745, lon: -94.4108 },
    '1260': { lat: 35.3461, lon: -118.9408 },
    '1267': { lat: 34.6145, lon: -118.0608 },
    '1269': { lat: 32.2622, lon: -109.2508 },
    '1272': { lat: 34.903765, lon: -116.887138 },
    '1281': { lat: 36.9222, lon: -111.4608 },
    '1283': { lat: 32.0622, lon: -96.4808 },
    '1284': { lat: 33.4345, lon: -94.1208 },
    '1287': { lat: 32.5422, lon: -95.6408 },
    '1288': { lat: 37.4222, lon: -86.8708 },
    '1289': { lat: 33.7822, lon: -96.5608 },
    '1290': { lat: 32.5345, lon: -96.8008 },
    '1292': { lat: 30.2261, lon: -97.1008 },
    '1294': { lat: 38.6261, lon: -87.5108 },
    '1297': { lat: 32.1745, lon: -96.8808 },
    '1299': { lat: 33.8222, lon: -98.1908 },
    '1303': { lat: 31.7822, lon: -95.6608 },
    '1315': { lat: 40.0061, lon: -75.0108 },
    '1317': { lat: 42.9461, lon: -74.3708 },
    '1319': { lat: 32.4461, lon: -97.2308 },
    '1323': { lat: 39.5422, lon: -94.7508 },
    '1326': { lat: 34.0901, lon: -117.3408 },
    '1328': { lat: 34.1261, lon: -117.3808 },
    '1336': { lat: 30.9545, lon: -90.5208 },
    '1346': { lat: 38.0661, lon: -97.3308 },
    '1347': { lat: 30.3661, lon: -89.7408 },
    '1354': { lat: 31.7822, lon: -102.4208 },
    '1360': { lat: 36.7585, lon: -88.6108 },
    '1370': { lat: 27.5545, lon: -99.4908 },
    '1372': { lat: 34.8622, lon: -114.1508 },
    '1380': { lat: 26.1585, lon: -97.9108 },
    '1381': { lat: 30.8661, lon: -96.6008 },
    '1382': { lat: 40.0501, lon: -104.6208 },
    '1383': { lat: 35.8422, lon: -90.6508 },
    '1384': { lat: 33.5622, lon: -116.0608 },
    '1385': { lat: 34.0585, lon: -117.3808 },
    '1390': { lat: 32.1461, lon: -81.4508 },
    '1399': { lat: 33.4985, lon: -112.3008 },
    '1412': { lat: 42.4545, lon: -87.8908 },
    '1433': { lat: 33.3061, lon: -111.9808 },
    '1436': { lat: 32.4422, lon: -85.7408 },
    '1439': { lat: 30.4822, lon: -91.2408 },
    '1440': { lat: 35.3301, lon: -91.5608 },
    '1450': { lat: 28.709762, lon: -100.46364 },
    '1452': { lat: 33.9422, lon: -87.8108 },
    '1458': { lat: 33.8061, lon: -117.2208 },
    '1461': { lat: 43.5622, lon: -87.8208 },
    '1467': { lat: 41.5101, lon: -87.6308 },
    '1470': { lat: 32.1622, lon: -94.3208 },
    '1476': { lat: 42.2622, lon: -88.8208 },
    '1483': { lat: 41.1422, lon: -87.8808 },
    '1490': { lat: 35.4022, lon: -89.5208 },
    '1549': { lat: 33.5801, lon: -86.1368 },
    '1550': { lat: 34.2261, lon: -86.8708 },
    '1577': { lat: 36.4622, lon: -84.4908 },
    '4556': { lat: 28.8711, lon: -82.0388 },
    '4557': { lat: 34.3361, lon: -83.2408 },
    '4558': { lat: 34.5222, lon: -84.9508 },
    '4559': { lat: 33.7145, lon: -84.9308 },
    '4560': { lat: 33.3035, lon: -83.9855 },
    '4561': { lat: 30.8022, lon: -83.2508 },
    '4562': { lat: 30.7945, lon: -81.6708 },
    '4563': { lat: 40.2461, lon: -76.7908 },
    '4566': { lat: 35.1322, lon: -81.4908 },
    '4568': { lat: 33.5822, lon: -81.8208 },
    '4569': { lat: 32.2745, lon: -81.0808 },
    '4576': { lat: 33.1843, lon: -80.579 },
    '4578': { lat: 34.3793, lon: -81.0873 },
    '4579': { lat: 33.6635, lon: -80.7792 },
    '4580': { lat: 34.211, lon: -81.5348 },
    '4581': { lat: 34.2185, lon: -80.2454 },
    '4584': { lat: 34.336, lon: -79.4328 },
    '4596': { lat: 36.1084, lon: -83.2921 },
    '4597': { lat: 36.177, lon: -85.9322 },
    '4598': { lat: 35.5167, lon: -84.5516 },
    '4599': { lat: 35.2415, lon: -85.8394 },
    '4619': { lat: 36.9496, lon: -81.0854 },
    '4622': { lat: 36.7029, lon: -78.9022 },
    '4642': { lat: 38.9668, lon: -78.4392 },
    '4649': { lat: 37.9287, lon: -79.2375 },
    '4651': { lat: 36.6579, lon: -77.7214 },
    '4656': { lat: 37.1557, lon: -77.2186 },
    '6955': { lat: 36.0954, lon: -79.3589 },
    '6978': { lat: 35.2963, lon: -79.8445 },
    '6990': { lat: 35.5921, lon: -78.125 },
    '6996': { lat: 34.9996, lon: -78.0933 },
    '7971': { lat: 35.7062, lon: -81.2165 },
    '7976': { lat: 35.7018, lon: -80.887 },
    '7983': { lat: 35.6707, lon: -80.4742 },
    '7996': { lat: 34.9854, lon: -80.5492 }
};

const stateCoordinates = {
    'AL': [32.806671, -86.791130, 7], 'AK': [61.370716, -152.404419, 4], 'AZ': [33.729759, -111.431221, 7], 'AR': [34.969704, -92.373123, 7],
    'CA': [36.116203, -119.681564, 6], 'CO': [39.059811, -105.311104, 7], 'CT': [41.597782, -72.755371, 9], 'DE': [39.318523, -75.507141, 9],
    'FL': [27.766279, -81.686783, 7], 'GA': [33.040619, -83.643074, 7], 'HI': [21.094318, -157.498337, 7], 'ID': [44.240459, -114.478828, 6],
    'IL': [40.349457, -88.986137, 7], 'IN': [39.849426, -86.258278, 7], 'IA': [42.011539, -93.210526, 7], 'KS': [38.526600, -96.726486, 7],
    'KY': [37.668140, -84.670067, 7], 'LA': [31.169546, -91.867805, 7], 'ME': [44.693947, -69.381927, 7], 'MD': [39.063946, -76.802101, 8],
    'MA': [42.230171, -71.530106, 8], 'MI': [43.326618, -84.536095, 7], 'MN': [45.694454, -93.900192, 6], 'MS': [32.741646, -89.678696, 7],
    'MO': [38.456085, -92.288368, 7], 'MT': [46.921925, -110.454353, 6], 'NE': [41.125370, -98.268082, 7], 'NV': [38.313515, -117.055374, 6],
    'NH': [43.452492, -71.563896, 8], 'NJ': [40.298904, -74.521011, 8], 'NM': [34.840515, -106.248482, 7], 'NY': [42.165726, -74.948051, 7],
    'NC': [35.630066, -79.806419, 7], 'ND': [47.528912, -99.784012, 7], 'OH': [40.388783, -82.764915, 7], 'OK': [35.565342, -96.928917, 7],
    'OR': [44.572021, -122.070938, 6], 'PA': [40.590752, -77.209755, 7], 'RI': [41.680893, -71.511780, 9], 'SC': [33.856892, -80.945007, 7],
    'SD': [44.299782, -99.438828, 7], 'TN': [35.747845, -86.692345, 7], 'TX': [31.054487, -97.563461, 6], 'UT': [40.150032, -111.862434, 7],
    'VT': [44.045876, -72.710686, 8], 'VA': [37.769337, -78.169968, 7], 'WA': [47.400902, -121.490494, 7], 'WV': [38.491226, -80.954453, 7],
    'WI': [44.268543, -89.616508, 7], 'WY': [42.755966, -107.302490, 7]
};

function updateStateSelector(filter = '') {
    const panel = document.getElementById('state-dropdown-panel');
    const input = document.getElementById('state-input');
    const allStationsRaw = Object.values(state.stationData).flat();
    const uniqueStates = [...new Set(allStationsRaw.map(s => s.state))].sort();

    // Clear previous options
    panel.innerHTML = '';

    // Function to handle selecting an option
    const selectOption = (value, text) => {
        state.selectedState = value;
        input.value = text;
        panel.classList.add('hidden'); // Close dropdown
        updateMapAndUI();

        // Trigger map zoom
        if (value === 'all') {
            map.setView([39.8283, -98.5795], 5);
        } else {
            const coords = stateCoordinates[value];
            if (coords) map.setView([coords[0], coords[1]], coords[2]);
        }
    };

    // Create and add the "All States" option
    const allStatesDiv = document.createElement('div');
    allStatesDiv.textContent = 'All';
    allStatesDiv.className = 'px-3 py-1.5 text-sm cursor-pointer hover:bg-blue-600';
    allStatesDiv.addEventListener('mousedown', () => selectOption('all', '')); // Use mousedown to fire before input's blur event
    panel.appendChild(allStatesDiv);

    // Filter and add state options
    const filteredStates = uniqueStates.filter(s => s.toLowerCase().startsWith(filter.toLowerCase()));

    filteredStates.forEach(s => {
        const optionDiv = document.createElement('div');
        optionDiv.textContent = s;
        optionDiv.className = 'px-3 py-1.5 text-sm cursor-pointer hover:bg-blue-600';
        optionDiv.addEventListener('mousedown', () => selectOption(s, s));
        panel.appendChild(optionDiv);
    });

    // Update input placeholder/value based on current selection
    if (state.selectedState === 'all') {
        input.value = '';
        input.placeholder = 'All';
    } else {
        input.value = state.selectedState;
    }
}

            function createProviderIcon(imageUrl) {
                return L.icon({
                    iconUrl: imageUrl,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                    popupAnchor: [0, -30],
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    shadowSize: [41, 41],
                    shadowAnchor: [12, 41]
                });
            }

            // --- DOM ELEMENTS ---
            const radiusSlider = document.getElementById('cluster-radius');
            const hideCheckbox = document.getElementById('hide-unclustered');
            const showTriadsCheckbox = document.getElementById('show-triads-only');
            const infoPlaceholder = document.getElementById('info-placeholder');
            const infoContent = document.getElementById('info-content');
            let allMarkers = [];

            // --- MODAL & FILE UPLOAD ELEMENTS ---
            const modal = document.getElementById('upload-modal');
            const modalPanel = document.getElementById('modal-panel');
            const openModalBtn = document.getElementById('open-modal-btn');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const fileInputModal = document.getElementById('file-upload-modal');
            const providerSelectModal = document.getElementById('provider-select-modal');
            const dropzone = document.getElementById('dropzone');
            const fileNameDisplay = document.getElementById('file-name-display');

            // --- NOTIFICATION SYSTEM ---
            function showNotification(message, level = 'info') {
                const container = document.getElementById('notification-container');
                const notification = document.createElement('div');
                
                let bgColor, textColor;
                switch(level) {
                    case 'error': bgColor = 'bg-red-600'; textColor = 'text-white'; break;
                    case 'warning': bgColor = 'bg-yellow-500'; textColor = 'text-black'; break;
                    default: bgColor = 'bg-blue-600'; textColor = 'text-white';
                }

                notification.className = `p-3 rounded-md shadow-lg ${bgColor} ${textColor} text-sm transition-all duration-300 opacity-0 transform translate-y-2`;
                notification.textContent = message;
                
                container.appendChild(notification);
                
                setTimeout(() => notification.classList.remove('opacity-0', 'translate-y-2'), 10);
                setTimeout(() => {
                    notification.classList.add('opacity-0');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, 5000);
            }

            // --- MODAL LOGIC ---
            function openModal() {
                modal.classList.remove('hidden');
                updateHelperText(); // <-- Call the new function
                setTimeout(() => { modalPanel.classList.remove('opacity-0', '-translate-y-4'); }, 10);
            }

            function closeModal() {
                modalPanel.classList.add('opacity-0', '-translate-y-4');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    fileNameDisplay.textContent = '';
                }, 300);
            }

            // --- NEW: Function to update modal helper text ---
            function updateHelperText() {
                const provider = providerSelectModal.value;
                const helperEl = document.getElementById('csv-helper-text');
                if (!helperEl) return;

                const originalText = `
                    CSV files must contain the following columns: <br>
                    <code class="text-blue-400">station_name</code>, <code class="text-blue-400">city</code>, <code class="text-blue-400">state</code>, <code class="text-blue-400">latitude</code>, <code class="text-blue-400">longitude</code>, <code class="text-blue-400">retail_price</code>, <code class="text-blue-400">discounted_price</code>, <code class="text-blue-400">savings</code>
                `;
                
                const newText = 'Upload the original received file.';

                switch(provider) {
                    case 'Pilot Flying J':
                    case 'Bobtail':
                    case 'Mudflap':
                        helperEl.innerHTML = newText;
                        break;
                    case 'Loves':
                    case 'Other':
                    default:
                        helperEl.innerHTML = originalText;
                        break;
                }
            }

            openModalBtn.addEventListener('click', openModal);
            closeModalBtn.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
            providerSelectModal.addEventListener('change', updateHelperText); // <-- Add this listener

            // --- FILE HANDLING ---
            function handleFile(file) {
                if (Object.keys(state.stationData).length >= 4) {
                    showNotification('Error: A maximum of 4 provider datasets can be loaded.', 'error');
                    closeModal();
                    return;
                }

                if (!file) {
                    showNotification('Error: No file selected.', 'error');
                    return;
                }

                const providerName = providerSelectModal.value;
                const fileName = file.name.toLowerCase();

                if (fileName.endsWith('.csv')) {
                    parseCSV(file, providerName); // Use PapaParse for CSV
                    closeModal();
                } else if (fileName.endsWith('.xls') || fileName.endsWith('.xlsx')) {
                    parseExcel(file, providerName); // Use SheetJS for Excel
                    closeModal();
                } else {
                    showNotification('Error: Please select a valid .csv, .xls, or .xlsx file.', 'error');
                }
            }
            
            dropzone.addEventListener('click', () => fileInputModal.click());
            fileInputModal.addEventListener('change', () => {
                if (fileInputModal.files.length > 0) {
                     fileNameDisplay.textContent = fileInputModal.files[0].name;
                     handleFile(fileInputModal.files[0]);
                }
                 fileInputModal.value = '';
            });
            
            dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('dropzone-active'); });
            dropzone.addEventListener('dragleave', () => { dropzone.classList.remove('dropzone-active'); });
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('dropzone-active');
                if (e.dataTransfer.files.length > 0) {
                     fileNameDisplay.textContent = e.dataTransfer.files[0].name;
                     handleFile(e.dataTransfer.files[0]);
                }
            });

            function parseCSV(file, provider) {
                // --- Store data temporarily for modals ---
                let parsedData = [];
                let papaHeaders = [];

                // 1. Special check for Pilot
                if (provider === 'Pilot Flying J') {
                    showNotification('Note for Pilot: Please ensure you have removed the first 5 rows (so headers are on row 1) and added "latitude" and "longitude" columns to your CSV before uploading.', 'warning');
                    // We still proceed, assuming they did.
                }

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    transformHeader: header => header.toLowerCase().trim(), // Auto-normalize headers
                    complete: function(results) {
                        try {
                            parsedData = results.data;
                            papaHeaders = results.meta.fields;

                            if (!parsedData || parsedData.length === 0) {
                                showNotification('Error: CSV file has no data after parsing.', 'error');
                                return;
                            }
                            
                            // 2. Get the correct header map
                            const headerMap = providerHeaderMaps[provider] || providerHeaderMaps['Other'];
                            
                            // 3. Check if all required headers (from the map) exist in the file
                            const requiredFileHeaders = Object.values(headerMap).filter(h => h !== null); // Filter out nulls like station_name for Pilot
                            const missingHeaders = requiredFileHeaders.filter(h => !papaHeaders.includes(h));

                            if (missingHeaders.length > 0) {
                                showNotification(`Error: Missing required columns for ${provider}: ${missingHeaders.join(', ')}`, 'error');
                                return;
                            }

                            // 4. --- Provider-Specific Modal Logic ---
                            if (provider === 'Mudflap') {
                                // Filter by card_type first
                                const creditData = parsedData.filter(row => row[headerMap.card_type]?.toLowerCase() === 'credit');
                                if (creditData.length === 0) {
                                    showNotification(`No rows found in ${file.name} where 'card_type' is 'credit'.`, 'warning');
                                    return;
                                }
                                
                                // Get unique product names
                                const productKey = headerMap.product_name;
                                const uniqueProducts = [...new Set(creditData.map(row => row[productKey]))].filter(Boolean); // Get unique, remove empty
                                
                                if (uniqueProducts.length > 1) {
                                    // Show modal to ask user which products to load
                                    const productList = document.getElementById('mudflap-product-list');
                                    productList.innerHTML = ''; // Clear old
                                    uniqueProducts.forEach((product, i) => {
                                        productList.innerHTML += `
                                            <label for="product-${i}" class="flex items-center space-x-2 text-gray-300 cursor-pointer">
                                                <input id="product-${i}" type="checkbox" value="${product}" class="form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-blue-600 rounded focus:ring-blue-500">
                                                <span>${product}</span>
                                            </label>
                                        `;
                                    });
                                    document.getElementById('mudflap-product-modal').classList.remove('hidden');
                                } else {
                                    // Only one product (or none), just process what we have
                                    processData(creditData, provider, { mudflapProducts: uniqueProducts });
                                }

                            } else if (provider === 'Bobtail') {
                                // Show modal to ask for price choice
                                document.getElementById('bobtail-choice-modal').classList.remove('hidden');
                            
                            } else {
                                // For Pilot, Loves, Other: process immediately
                                processData(parsedData, provider, {});
                            }

                        } catch (error) {
                             showNotification('An unexpected error occurred during processing.', 'error');
                             console.error("Processing Error:", error);
                        }
                    },
                    error: function(err) {
                        showNotification('Fatal error parsing CSV file. The file may be corrupt.', 'error');
                        console.error("Papa Parse Fatal Error:", err);
                    }
                });

                // --- NEW Modal Event Listeners (placed inside parseCSV to access parsedData) ---
                
                // --- Mudflap Modal ---
                document.getElementById('mudflap-confirm-btn').onclick = () => {
                    const selectedProducts = [];
                    document.querySelectorAll('#mudflap-product-list input[type="checkbox"]:checked').forEach(cb => {
                        selectedProducts.push(cb.value);
                    });

                    if (selectedProducts.length === 0) {
                        showNotification('Please select at least one product to load.', 'warning');
                        return;
                    }
                    
                    const creditData = parsedData.filter(row => row[providerHeaderMaps['Mudflap'].card_type]?.toLowerCase() === 'credit');
                    processData(creditData, 'Mudflap', { mudflapProducts: selectedProducts });
                    document.getElementById('mudflap-product-modal').classList.add('hidden');
                };

                document.getElementById('mudflap-cancel-btn').onclick = () => {
                    document.getElementById('mudflap-product-modal').classList.add('hidden');
                    showNotification('File load cancelled.', 'info');
                };

                // --- Bobtail Modal ---
                document.getElementById('bobtail-choice-regular').onclick = () => {
                    processData(parsedData, 'Bobtail', { bobtailPriceChoice: 'regular' });
                    document.getElementById('bobtail-choice-modal').classList.add('hidden');
                };

                document.getElementById('bobtail-choice-large-only').onclick = () => {
                    processData(parsedData, 'Bobtail', { bobtailPriceChoice: 'large_fleet_only' });
                    document.getElementById('bobtail-choice-modal').classList.add('hidden');
                };

                document.getElementById('bobtail-choice-fallback').onclick = () => {
                    processData(parsedData, 'Bobtail', { bobtailPriceChoice: 'large_fleet_fallback' });
                    document.getElementById('bobtail-choice-modal').classList.add('hidden');
                };

                document.getElementById('bobtail-cancel-btn').onclick = () => {
                    document.getElementById('bobtail-choice-modal').classList.add('hidden');
                    showNotification('File load cancelled.', 'info');
                };
            }

            /**
             * NEW: This function parses .xls and .xlsx files using SheetJS
             */
             function parseExcel(file, provider) {
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const data = e.target.result;
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Get the first sheet name and sheet
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // --- THIS IS THE FIX ---
                        // Set options for the JSON conversion
                        const jsonOptions = { 
                            raw: true, // <-- FIX: Get raw numbers, not formatted strings
                            defval: null // Set blank cells to null
                        };

                        // If the provider is Pilot, tell SheetJS to start reading from Row 6
                        if (provider === 'Pilot Flying J') {
                            // FIX: SheetJS is 0-indexed. 
                            // range: 5 means "skip the first 5 rows (0-4) and start on row 6 (index 5)"
                            // This row will be correctly used as the header.
                            jsonOptions.range = 5; 
                        }
                        // For all other providers, it uses the default (Row 1)
                        // --- END OF FIX ---

                        const jsonData = XLSX.utils.sheet_to_json(worksheet, jsonOptions);

                        if (!jsonData || jsonData.length === 0) {
                            showNotification('Error: Excel file has no data after parsing.', 'error');
                            return;
                        }

                        // --- CRITICAL STEP: Normalize all headers to lowercase ---
                        // Our processData function expects lowercase headers.
                        const normalizedData = jsonData.map(row => {
                            const newRow = {};
                            Object.keys(row).forEach(key => {
                                const newKey = key.toLowerCase().trim();
                                newRow[newKey] = row[key];
                            });
                            return newRow;
                        });

                        // 1. Get the correct header map
                        const headerMap = providerHeaderMaps[provider] || providerHeaderMaps['Other'];
                        
                        // 2. Check for required headers in our normalized data
                        const fileHeaders = Object.keys(normalizedData[0]);
                        const requiredFileHeaders = Object.values(headerMap).filter(h => h !== null); // Filter out nulls

                        // --- NEW: DEBUGGING CONSOLE LOGS ---
                        console.log("--- DEBUGGING UPLOAD ---");
                        console.log("Provider:", provider);
                        console.log("Headers REQUIRED by map:", requiredFileHeaders);
                        console.log("Headers FOUND in file (normalized):", fileHeaders);
                        // --- END: DEBUGGING CONSOLE LOGS ---

                        const missingHeaders = requiredFileHeaders.filter(h => !fileHeaders.includes(h));

                        if (missingHeaders.length > 0) {
                            showNotification(`Error: Missing required columns for ${provider}: ${missingHeaders.join(', ')}`, 'error');
                            return;
                        }
                        
                        // 3. --- Provider-Specific Modal Logic ---
                        if (provider === 'Mudflap') {
                            const creditData = normalizedData.filter(row => row[headerMap.card_type]?.toLowerCase() === 'credit');
                            if (creditData.length === 0) {
                                showNotification(`No rows found in ${file.name} where 'card_type' is 'credit'.`, 'warning');
                                return;
                            }
                            const productKey = headerMap.product_name;
                            const uniqueProducts = [...new Set(creditData.map(row => row[productKey]))].filter(Boolean);
                            
                            if (uniqueProducts.length > 1) {
                                const productList = document.getElementById('mudflap-product-list');
                                productList.innerHTML = '';
                                uniqueProducts.forEach((product, i) => {
                                    productList.innerHTML += `
                                        <label for="product-${i}" class="flex items-center space-x-2 text-gray-300 cursor-pointer">
                                            <input id="product-${i}" type="checkbox" value="${product}" class="form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-blue-600 rounded focus:ring-blue-500">
                                            <span>${product}</span>
                                        </label>
                                    `;
                                });
                                document.getElementById('mudflap-product-modal').classList.remove('hidden');

                                // --- Add Mudflap listeners (now inside the Excel parser) ---
                                document.getElementById('mudflap-confirm-btn').onclick = () => {
                                    const selectedProducts = [];
                                    document.querySelectorAll('#mudflap-product-list input[type="checkbox"]:checked').forEach(cb => selectedProducts.push(cb.value));
                                    if (selectedProducts.length === 0) {
                                        showNotification('Please select at least one product to load.', 'warning');
                                        return;
                                    }
                                    processData(creditData, 'Mudflap', { mudflapProducts: selectedProducts });
                                    document.getElementById('mudflap-product-modal').classList.add('hidden');
                                };
                                document.getElementById('mudflap-cancel-btn').onclick = () => {
                                    document.getElementById('mudflap-product-modal').classList.add('hidden');
                                    showNotification('File load cancelled.', 'info');
                                };

                            } else {
                                processData(creditData, provider, { mudflapProducts: uniqueProducts });
                            }

                        } else if (provider === 'Bobtail') {
                            document.getElementById('bobtail-choice-modal').classList.remove('hidden');
                            
                            // --- Add Bobtail listeners (now inside the Excel parser) ---
                             document.getElementById('bobtail-choice-regular').onclick = () => {
                                processData(normalizedData, 'Bobtail', { bobtailPriceChoice: 'regular' });
                                document.getElementById('bobtail-choice-modal').classList.add('hidden');
                            };
                            document.getElementById('bobtail-choice-large-only').onclick = () => {
                                processData(normalizedData, 'Bobtail', { bobtailPriceChoice: 'large_fleet_only' });
                                document.getElementById('bobtail-choice-modal').classList.add('hidden');
                            };
                            document.getElementById('bobtail-choice-fallback').onclick = () => {
                                processData(normalizedData, 'Bobtail', { bobtailPriceChoice: 'large_fleet_fallback' });
                                document.getElementById('bobtail-choice-modal').classList.add('hidden');
                            };
                            document.getElementById('bobtail-cancel-btn').onclick = () => {
                                document.getElementById('bobtail-choice-modal').classList.add('hidden');
                                showNotification('File load cancelled.', 'info');
                            };

                        } else {
                            // For Pilot, Loves, Other: process immediately
                            processData(normalizedData, provider, {});
                        }

                    } catch (error) {
                        console.error("Excel Parsing Error:", error);
                        showNotification('An unexpected error occurred parsing the Excel file.', 'error');
                    }
                };

                reader.onerror = function(ex) {
                    console.error("FileReader Error:", ex);
                    showNotification('Error reading file.', 'error');
                };

                // Read the file as an ArrayBuffer
                reader.readAsArrayBuffer(file);
            }



            /**
             * NEW: This function processes the data after all user options are selected.
             * @param {object[]} data - The raw data from PapaParse.
             * @param {string} provider - The selected provider name.
             * @param {object} options - Provider-specific options, e.g., { bobtailPriceChoice: 'large_fleet' }
             */
             function processData(data, provider, options = {}) {
                const headerMap = providerHeaderMaps[provider] || providerHeaderMaps['Other'];
                const processedData = [];
                let discardedRows = 0;
                let siteKeyLog = new Set(); // --- DEBUG: To store site keys we've tried

                // --- NEW: Detailed discard counters ---
                let discardReasons = {
                    lat_lon: 0,
                    site_id: 0,
                    price: 0,
                    bobtail_choice: 0
                };

                // 1. Apply pre-filters if any
                let filteredData = data;
                if (provider === 'Mudflap' && options.mudflapProducts) {
                    const productKey = headerMap.product_name;
                    filteredData = data.filter(row => options.mudflapProducts.includes(row[productKey]));
                }

                // 2. Iterate and map data
                filteredData.forEach((row, index) => {
                    let lat, lon;
                    let identifier = `Row ${index + 2}`; // Default identifier

                    // --- NEW: Pilot-specific coordinate lookup ---
                    if (provider === 'Pilot Flying J') {
                        let siteValue = row[headerMap.site]; // e.g., row['site']
                        
                        if (!siteValue) { // Skip if site is null or empty
                            discardedRows++;
                            return;
                        }

                        let siteKey = String(siteValue).trim();
                        siteKey = siteKey.padStart(3, '0');
                        identifier = `Site ${siteKey}`; // Use Site as identifier
                        
                        if (index < 5) siteKeyLog.add(siteKey); // --- DEBUG: Log the first 5 keys we try

                        const coords = pilotSiteMap[siteKey]; // Look up with the correct '001' key
                        
                        if (!coords) {
                            // Site not in our map (e.g., '360' or '1272' from your list)
                            console.warn(`Discarded row (invalid Site ID): ${identifier}`);
                            discardReasons.site_id++;
                            discardedRows++;
                            return; 
                        }
                        lat = coords.lat;
                        lon = coords.lon;
                    } else {
                        // Logic for all other providers
                        lat = parseFloat(row[headerMap.latitude]);
                        lon = parseFloat(row[headerMap.longitude]);
                        identifier = `Station: ${row[headerMap.station_name] || 'N/A'}`; // Use Station Name as identifier
                    }
                    // --- END of new logic ---

                    if (isNaN(lat) || isNaN(lon)) {
                        console.warn(`Discarded row (invalid lat/lon): ${identifier}`, { 
                            lat_raw: (provider === 'Pilot Flying J') ? 'N/A (hardcoded)' : row[headerMap.latitude], 
                            lon_raw: (provider === 'Pilot Flying J') ? 'N/A (hardcoded)' : row[headerMap.longitude] 
                        });
                        discardReasons.lat_lon++;
                        discardedRows++;
                        return; // Use 'return' instead of 'continue' in forEach
                    }

                    let discountedPrice, retailPrice, savings, stationName;
                    
                    retailPrice = parseFloat(row[headerMap.retail_price]);
                    stationName = (provider === 'Pilot Flying J') ? 'Pilot Flying J' : row[headerMap.station_name];

                    // --- Provider-Specific Price Logic ---
                    if (provider === 'Bobtail') {
                        const regularDiscount = parseFloat(row[headerMap.discounted_price]);
                        const regularSavings = parseFloat(row[headerMap.savings]);
                        const largeFleetDiscount = parseFloat(row[headerMap.large_fleet_discount_price]);
                        const largeFleetSavings = parseFloat(row[headerMap.large_fleet_savings]);

                        if (options.bobtailPriceChoice === 'large_fleet_only') {
                            // Use only large fleet price. If invalid, discard the row.
                            if (isNaN(largeFleetDiscount) || largeFleetDiscount <= 0) {
                                console.warn(`Discarded row (no Large Fleet price): ${identifier}`);
                                discardReasons.bobtail_choice++; // <-- Track reason
                                discardedRows++;
                                return; // Discard row
                            }
                            discountedPrice = largeFleetDiscount;
                            savings = largeFleetSavings;

                        } else if (options.bobtailPriceChoice === 'large_fleet_fallback') {
                            // Use large fleet price if valid, otherwise fall back to regular price
                            discountedPrice = (isNaN(largeFleetDiscount) || largeFleetDiscount <= 0) ? regularDiscount : largeFleetDiscount;
                            savings = (isNaN(largeFleetSavings) || largeFleetSavings === 0) ? regularSavings : largeFleetSavings;
                        
                        } else {
                            // This is 'regular' (Regular Price Only)
                            if (isNaN(regularDiscount) || regularDiscount <= 0) {
                                console.warn(`Discarded row (no Regular price): ${identifier}`);
                                discardReasons.bobtail_choice++; // <-- Track reason
                                discardedRows++;
                                return; // Discard row
                            }
                            discountedPrice = regularDiscount;
                            savings = regularSavings;
                        }
                    } else {
                        // Standard logic for Mudflap, Pilot, Loves, Other
                        discountedPrice = parseFloat(row[headerMap.discounted_price]);
                        savings = parseFloat(row[headerMap.savings]);
                    }
                    // --- End of Price Logic ---

                    // --- DEBUG: Log prices for first row ---
                    if (provider === 'Pilot Flying J' && index === 0) {
                        console.log("--- DEBUG: First Row Price Check ---");
                        console.log("Raw Retail Price:", row[headerMap.retail_price], "(Type: " + typeof row[headerMap.retail_price] + ")");
                        console.log("Parsed Retail Price:", retailPrice);
                        console.log("Raw Discounted Price:", row[headerMap.discounted_price], "(Type: " + typeof row[headerMap.discounted_price] + ")");
                        console.log("Parsed Discounted Price:", discountedPrice);
                    }
                    // --- END DEBUG ---

                    // If discounted price is not a valid positive number, use retail price instead.
                    if (isNaN(discountedPrice) || discountedPrice <= 0) {
                        discountedPrice = retailPrice;
                    }
                    
                    // If, after all checks, the price is still invalid, discard the row.
                    if (isNaN(discountedPrice)) {
                         console.warn(`Discarded row (invalid final price): ${identifier}`, {
                            retail_raw: row[headerMap.retail_price],
                            discounted_raw: row[headerMap.discounted_price]
                         });
                         discardReasons.price++;
                         discardedRows++;
                         return;
                    }

                    processedData.push({
                        provider: provider,
                        lat: lat,
                        lon: lon,
                        name: stationName,
                        retail: retailPrice,
                        discounted: discountedPrice,
                        savings: isNaN(savings) ? 0 : savings,
                        city: row[headerMap.city],
                        state: row[headerMap.state],
                        id: `${provider}-${lat}-${lon}` // Use the parsed lat/lon for a stable ID
                    });
                });

                // --- DEBUG: Log the site keys we tried to find ---
                if (provider === 'Pilot Flying J') {
                    console.log("--- DEBUG: First 5 Site Keys tried ---");
                    console.log(Array.from(siteKeyLog));
                }
                
                // 3. Finalize and update UI - (FIXED NOTIFICATION LOGIC)
                const totalRowsProcessed = filteredData.length;
                const loadedRows = processedData.length;
                
                if (loadedRows > 0) {
                     showNotification(`Successfully loaded ${loadedRows} stations for ${provider}.`, 'info');
                }

                if (discardedRows > 0) {
                    // --- NEW: Build dynamic notification message ---
                    let discardMsg = "";
                    // If the *only* reason for discards was the Bobtail choice:
                    if (provider === 'Bobtail' && discardReasons.bobtail_choice > 0 && discardReasons.lat_lon === 0 && discardReasons.price === 0 && discardReasons.site_id === 0) {
                        discardMsg = `(${discardReasons.bobtail_choice} rows did not match your selected price type)`;
                    } else {
                        // Otherwise, build a generic but detailed message
                        let parts = [];
                        if (discardReasons.lat_lon > 0) parts.push("invalid lat/lon");
                        if (discardReasons.site_id > 0) parts.push("invalid Site ID");
                        if (discardReasons.price > 0) parts.push("invalid prices");
                        if (discardReasons.bobtail_choice > 0) parts.push("unselected price type");
                        
                        if (parts.length > 0) {
                            discardMsg = `(reasons: ${parts.join(', ')})`;
                        } else {
                            discardMsg = "(see console for details)";
                        }
                    }
                    showNotification(`${discardedRows} out of ${totalRowsProcessed} rows were discarded ${discardMsg}`, 'warning');
                    // --- END: New notification ---
                }

                if (loadedRows === 0 && totalRowsProcessed > 0) {
                    showNotification(`All ${totalRowsProcessed} rows were discarded. Check console for debug info.`, 'error');
                }

                if (loadedRows === 0 && discardedRows === 0) {
                    showNotification(`No data found in file for ${provider}.`, 'warning');
                }

                if (!state.stationData[provider]) {
                    state.stationData[provider] = [];
                }
                state.stationData[provider] = [...state.stationData[provider], ...processedData];
                
                if (Object.keys(state.stationData).length === 4) {
                    state.showTriadsOnly = false;
                    document.getElementById('show-triads-only').checked = false;
                    state.showTetradsOnly = true;
                    document.getElementById('show-tetrads-only').checked = true;
                    state.competitiveFilter = 'tetrads';
                    showNotification('Four providers loaded. Switched to Tetrads Only mode.', 'info');
                } else if (Object.keys(state.stationData).length === 3) {
                    state.showTriadsOnly = true;
                    document.getElementById('show-triads-only').checked = true;
                    state.competitiveFilter = 'triads';
                    showNotification('Three providers loaded. Switched to Triads Only mode.', 'info');
                }
                updateMapAndUI();
            }

            // --- UTILITY FUNCTIONS ---
            const milesToMeters = (miles) => miles * 1609.34;

            function findCompetitivePairs(allStations) {
                const radiusMeters = milesToMeters(state.clusterRadius);
                
                allStations.forEach(s => {
                    s.competitors = [];
                    s.triads = [];
                    s.tetrads = [];
                    s.isPaired = false;
                    s.isTriadPaired = false;
                    s.isTetradPaired = false;
                });

                const providerNames = Object.keys(state.stationData);
                const stationsByProvider = {};
                providerNames.forEach(p => {
                    stationsByProvider[p] = allStations.filter(s => s.provider === p);
                });

                if (providerNames.length === 4) {
    const stationsA = stationsByProvider[providerNames[0]];
    const stationsB = stationsByProvider[providerNames[1]];
    const stationsC = stationsByProvider[providerNames[2]];
    const stationsD = stationsByProvider[providerNames[3]];

    for (const sA of stationsA) {
        const latLngA = L.latLng(sA.lat, sA.lon);
        for (const sB of stationsB) {
            const latLngB = L.latLng(sB.lat, sB.lon);
            if (latLngA.distanceTo(latLngB) > radiusMeters) continue;

            for (const sC of stationsC) {
                const latLngC = L.latLng(sC.lat, sC.lon);
                if (latLngA.distanceTo(latLngC) > radiusMeters || latLngB.distanceTo(latLngC) > radiusMeters) continue;

                for (const sD of stationsD) {
                    const latLngD = L.latLng(sD.lat, sD.lon);
                    // Check all remaining distances to ensure all 6 connections exist
                    if (latLngA.distanceTo(latLngD) <= radiusMeters && latLngB.distanceTo(latLngD) <= radiusMeters && latLngC.distanceTo(latLngD) <= radiusMeters) {
                        sA.isTetradPaired = sB.isTetradPaired = sC.isTetradPaired = sD.isTetradPaired = true;
                        sA.tetrads.push([sB, sC, sD]);
                        sB.tetrads.push([sA, sC, sD]);
                        sC.tetrads.push([sA, sB, sD]);
                        sD.tetrads.push([sA, sB, sC]);
                    }
                }
            }
        }
    }
}

                if (providerNames.length >= 3) {
                    // Combination logic to find all unique sets of 3 providers
                    for (let i = 0; i < providerNames.length; i++) {
                        for (let j = i + 1; j < providerNames.length; j++) {
                            for (let k = j + 1; k < providerNames.length; k++) {
                                const [pA, pB, pC] = [providerNames[i], providerNames[j], providerNames[k]];
                                for (const stationA of stationsByProvider[pA]) {
                                    const latLngA = L.latLng(stationA.lat, stationA.lon);
                                    const nearbyB = stationsByProvider[pB].filter(s => latLngA.distanceTo(L.latLng(s.lat, s.lon)) <= radiusMeters);
                                    const nearbyC = stationsByProvider[pC].filter(s => latLngA.distanceTo(L.latLng(s.lat, s.lon)) <= radiusMeters);

                                    if (nearbyB.length > 0 && nearbyC.length > 0) {
                                        for (const stationB of nearbyB) {
                                            for (const stationC of nearbyC) {
                                                if (L.latLng(stationB.lat, stationB.lon).distanceTo(L.latLng(stationC.lat, stationC.lon)) <= radiusMeters) {
                                                    stationA.isTriadPaired = true; stationB.isTriadPaired = true; stationC.isTriadPaired = true;
                                                    stationA.triads.push([stationB, stationC]);
                                                    stationB.triads.push([stationA, stationC]);
                                                    stationC.triads.push([stationA, stationB]);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                for (let i = 0; i < allStations.length; i++) {
                    const stationA = allStations[i];
                    for (let j = i + 1; j < allStations.length; j++) {
                        const stationB = allStations[j];
                        if (stationA.provider === stationB.provider) continue;

                        const distance = L.latLng(stationA.lat, stationA.lon).distanceTo(L.latLng(stationB.lat, stationB.lon));
                        if (distance <= radiusMeters) {
                            stationA.isPaired = true;
                            stationB.isPaired = true;
                            stationA.competitors.push(stationB);
                            stationB.competitors.push(stationA);
                        }
                    }
                }
            }

            // --- MAP & UI UPDATES ---
            function updateMapAndUI() {
                state.markers.clearLayers();
                allMarkers = [];
                // Get the raw, unfiltered list of all stations
                const allStationsRaw = Object.values(state.stationData).flat();

                // Filter the list based on the selected state, or use the full list if 'all' is selected
                const allStations = state.selectedState === 'all'
                    ? allStationsRaw
                    : allStationsRaw.filter(station => station.state === state.selectedState);
                const providerCount = Object.keys(state.stationData).length;

                // Show/hide the toggles based on provider count
                document.getElementById('triads-only-container').classList.toggle('hidden', providerCount < 3);
                document.getElementById('tetrads-only-container').classList.toggle('hidden', providerCount < 4);

                // Enable/disable the "Upload Data" button
                const openModalBtn = document.getElementById('open-modal-btn');
                openModalBtn.disabled = providerCount >= 4;
                openModalBtn.classList.toggle('opacity-50', providerCount >= 4);
                openModalBtn.classList.toggle('cursor-not-allowed', providerCount >= 4);
                
                if (allStations.length > 0) {
                    findCompetitivePairs(allStations);
                }

                // --- Calculate Statistics ---
                const unpairedByProvider = {};
                Object.keys(state.stationData).forEach(p => { unpairedByProvider[p] = 0; });

                const unpairedCount = allStations.filter(s => {
                    const isUnpaired = !s.isPaired && !s.isTriadPaired && !s.isTetradPaired;
                    if (isUnpaired) unpairedByProvider[s.provider]++;
                    return isUnpaired;
                }).length;

                const pairedOnlyCount = allStations.filter(s => s.isPaired && !s.isTriadPaired && !s.isTetradPaired).length;

                const pairLinks = new Set();
                allStations.forEach(s => s.isPaired && s.competitors.forEach(c => pairLinks.add([s.id, c.id].sort().join('|'))));
                
                const triadGroups = new Set();
                allStations.forEach(s => s.isTriadPaired && s.triads.forEach(p => triadGroups.add([s.id, p[0].id, p[1].id].sort().join('|'))));
                
                const tetradGroups = new Set();
                allStations.forEach(s => s.isTetradPaired && s.tetrads.forEach(p => tetradGroups.add([s.id, p[0].id, p[1].id, p[2].id].sort().join('|'))));

                // --- Update UI Counters ---
                const counters = {
                    'unpaired-counter': { value: unpairedCount, label: 'Unpaired', color: 'yellow-400' },
                    'paired-only-counter': { value: pairedOnlyCount, label: 'in Pairs', color: 'blue-400' },
                    'pair-links-counter': { value: pairLinks.size, label: 'Pair Links', color: 'red-400' },
                    'triad-groups-counter': { value: triadGroups.size, label: 'Triads', color: 'green-400' },
                    'tetrad-groups-counter': { value: tetradGroups.size, label: 'Tetrads', color: 'blue-400' },
                };

                const separators = document.querySelectorAll('.stat-separator');
                if (allStations.length > 0) {
                    Object.entries(counters).forEach(([id, {value, label, color}]) => {
                        const el = document.getElementById(id);
                        if (el) {
                            // This line is updated for smaller fonts
                            el.innerHTML = `<span class="font-semibold text-sm text-${color}">${value}</span> <span class="text-[10px] text-gray-500">${label}</span>`;
                        }
                    });
                    separators.forEach(sep => sep.classList.remove('hidden'));
                } else {
                    Object.keys(counters).forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.innerHTML = '';
                    });
                    separators.forEach(sep => sep.classList.add('hidden'));
                }
                
                // Hide Tetrad counter and its separator if provider count < 4
                const tetradCounter = document.getElementById('tetrad-groups-counter');
                if (tetradCounter) {
                    const tetradSeparator = tetradCounter.previousElementSibling;
                    const shouldHide = providerCount < 4;
                    tetradCounter.classList.toggle('hidden', shouldHide);
                    if (tetradSeparator && tetradSeparator.classList.contains('stat-separator')) {
                        tetradSeparator.classList.toggle('hidden', shouldHide);
                    }
                }

                // Update tooltip
                const tooltipEl = document.getElementById('unpaired-tooltip');
                let tooltipHtml = '<div class="font-bold text-white mb-1 border-b border-gray-700 pb-1">Unpaired by Provider</div>';
                Object.entries(unpairedByProvider).forEach(([p, c]) => { tooltipHtml += `<div class="flex justify-between items-center space-x-4"><span>${p}</span><span class="font-mono font-semibold">${c.toLocaleString()}</span></div>`; });
                tooltipEl.innerHTML = tooltipHtml;

                // --- Manage Checkbox States ---
                const showTriadsCheckbox = document.getElementById('show-triads-only');
                showTriadsCheckbox.disabled = providerCount < 3;
                if(showTriadsCheckbox.disabled) { showTriadsCheckbox.checked = false; state.showTriadsOnly = false; }

                const showTetradsCheckbox = document.getElementById('show-tetrads-only');
                showTetradsCheckbox.disabled = providerCount < 4;
                if(showTetradsCheckbox.disabled) { showTetradsCheckbox.checked = false; state.showTetradsOnly = false; }


                allStations.forEach(station => {
                    allMarkers.push(createStationMarker(station));
                });

                applyVisibilityFilter(); // This adds markers to state.markers
                updateProviderList();
                renderAnalysisSidebar(allStations);
                updateLineVisibility();
                
                // --- NEW: Update bracket system ---
                populatePriceBracketProviders();
                if (state.showPriceBrackets) {
                    drawPriceBrackets(); // Redraw brackets if data changes
                }
                updatePriceBracketVisibility(); // Ensure correct layer is visible
            }

            // <-- NEW: Extracted popup content generation -->
            function createStationPopupContent(station) {
                const iconUrl = providerIcons[station.provider] || providerIcons['Other'];
                const retailPrice = station.retail || 0;
                const savingsAmount = station.savings || 0;
                const finalDiscountedPrice = station.discounted || retailPrice;

                return `
                    <div class="bg-gray-800 text-gray-300 text-sm font-sans">
                        <div class="p-2 bg-gray-900/50">
                            <h3 class="font-bold text-base text-blue-400 leading-tight mb-0">${station.name}</h3>
                            <p class="text-xs text-gray-400 leading-tight">${station.city}, ${station.state}</p>
                        </div>
                        <div class="p-2">
                            <div class="flex items-center mb-2">
                                <img src="${iconUrl}" class="w-5 h-5 mr-2 rounded-sm">
                                <span class="font-semibold text-base">${station.provider}</span>
                            </div>
                            <div class="space-y-1 text-sm">
                                <div class="flex justify-between items-center"><span class="text-gray-400">Retail Price</span><span class="font-mono">$${retailPrice.toFixed(2)}</span></div>
                                <div class="flex justify-between items-center"><span class="text-gray-400">Savings</span><span class="font-mono">-$${savingsAmount.toFixed(2)}</span></div>
                            </div>
                            <div class="flex justify-between items-center mt-2 pt-2 border-t border-gray-700">
                                <span class="font-bold text-base text-white">Discounted Price</span>
                                <span class="font-mono font-bold text-lg text-green-400">$${finalDiscountedPrice.toFixed(2)}</span>
                            </div>
                        </div>
                    </div>`;
            }

            function createStationMarker(station) {
                const iconUrl = providerIcons[station.provider] || providerIcons['Other'];
                const customIcon = createProviderIcon(iconUrl);
                const marker = L.marker([station.lat, station.lon], { icon: customIcon });

                const popupContent = createStationPopupContent(station); // <-- Use extracted function
                marker.bindPopup(popupContent);
                marker.stationData = station;

                marker.on('click', (e) => {
    if (state.showLines) return; // If lines are already visible, do nothing

    L.DomEvent.stopPropagation(e);
    state.tempLinesLayer.clearLayers();

    const currentOpacity = state.lineOpacity;
    const fillOpacity = Math.max(0.05, currentOpacity * 0.15);

    // Check for the highest-level grouping first
    if (station.isTetradPaired && station.tetrads.length > 0) {
        station.tetrads.forEach(partners => {
            const allPoints = [station, ...partners];

            // Sort points by angle around their centroid to form a valid polygon
            let totalLat = 0, totalLon = 0;
            allPoints.forEach(p => { totalLat += p.lat; totalLon += p.lon; });
            const centerLat = totalLat / 4;
            const centerLon = totalLon / 4;
            allPoints.sort((a, b) => {
                const angleA = Math.atan2(a.lat - centerLat, a.lon - centerLon);
                const angleB = Math.atan2(b.lat - centerLat, b.lon - centerLon);
                return angleA - angleB;
            });

            const sortedCoords = allPoints.map(p => [p.lat, p.lon]);

            L.polygon(sortedCoords, { color: '#3b82f6', weight: 2, opacity: currentOpacity, fillOpacity: fillOpacity }).addTo(state.tempLinesLayer);
        });
    } else if (station.isTriadPaired && station.triads.length > 0) {
        station.triads.forEach(partners => {
            const points = [[station.lat, station.lon], [partners[0].lat, partners[0].lon], [partners[1].lat, partners[1].lon]];
            L.polygon(points, { color: '#16a34a', weight: 2, opacity: currentOpacity, fillOpacity: fillOpacity }).addTo(state.tempLinesLayer);
        });
    } else if (station.isPaired) {
         station.competitors.forEach(competitor => {
             L.polyline([[station.lat, station.lon], [competitor.lat, competitor.lon]], { color: '#e74c3c', weight: 2, opacity: currentOpacity, dashArray: '5, 5' }).addTo(state.tempLinesLayer);
         });
    }

    map.invalidateSize();
});

                return marker;
            }
            
            function updateProviderList() {
                const container = document.getElementById('file-upload-section');
                container.innerHTML = (Object.keys(state.stationData).length === 0) 
                    ? `<span class="text-xs text-gray-500 italic">No datasets loaded</span>` 
                    : '';

                Object.entries(state.stationData).forEach(([provider, data]) => {
                    const iconUrl = providerIcons[provider] || providerIcons['Other'];
                    const pill = document.createElement('div');
                    // This line is updated for a smaller pill
                    pill.className = 'flex items-center bg-gray-700 text-xs font-medium pl-1.5 pr-1.5 py-0.5 rounded-full';
                    pill.innerHTML = `
                        <img src="${iconUrl}" class="w-4 h-4 mr-1.5 rounded-full object-cover">
                        <span>${provider} (${data.length})</span>
                        <button data-provider="${provider}" class="remove-btn ml-1.5 text-gray-400 hover:text-white hover:bg-gray-600 rounded-full p-0.5">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </button>`;
                    container.appendChild(pill);
                });

                container.querySelectorAll('.remove-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const providerToRemove = e.currentTarget.dataset.provider;
                        delete state.stationData[providerToRemove];
                        const providerCount = Object.keys(state.stationData).length;

                        if (providerCount < 4) {
                             if (state.showTetradsOnly) {
                                showNotification('Provider count is less than four. Reverting from Tetrads mode.', 'info');
                            }
                            state.showTetradsOnly = false;
                            document.getElementById('show-tetrads-only').checked = false;
                        }
                        if (providerCount < 3) {
                            if (state.showTriadsOnly) {
                                showNotification('Provider count is less than three. Reverting from Triads mode.', 'info');
                            }
                            state.showTriadsOnly = false;
                            document.getElementById('show-triads-only').checked = false;
                        }
                        
                        // Reset competitive filter if active mode is no longer possible
                        if ((state.competitiveFilter === 'tetrads' && providerCount < 4) || (state.competitiveFilter === 'triads' && providerCount < 3)) {
                            state.competitiveFilter = 'all';
                        }
                        
                        updateMapAndUI();
                        showNotification(`Removed ${providerToRemove} dataset.`, 'info');
                    });
                });
            }

            // --- ANALYSIS & RENDERING ENGINE ---
            function renderAnalysisSidebar(allStations) {
                const providerCount = Object.keys(state.stationData).length;


                if (providerCount < 2) {
                    infoPlaceholder.classList.remove('hidden');
                    infoContent.classList.add('hidden');
                    return;
                }
                
                let stationsForAnalysis;
let filterForAnalysis;

if (state.showTetradsOnly) {
    filterForAnalysis = 'tetrads';
    stationsForAnalysis = allStations.filter(s => s.isTetradPaired);
} else if (state.showTriadsOnly) {
    filterForAnalysis = 'triads';
    stationsForAnalysis = allStations.filter(s => s.isTriadPaired);
} else {
    filterForAnalysis = 'all';
    stationsForAnalysis = allStations.filter(s => s.isPaired || s.isTriadPaired || s.isTetradPaired);
}

                const providerTotals = {};
                Object.keys(state.stationData).forEach(provider => {
                    providerTotals[provider] = allStations.filter(s => s.provider === provider).length;
                });

                const metric = state.analysisMetric;
                const bestDealStats = calculateBestDealStats(allStations, metric, filterForAnalysis);
                const priceStats = calculatePriceStatistics(stationsForAnalysis, metric);
                const bucketStats = calculateBucketCounts(stationsForAnalysis, metric);
                const matchupStats = calculateMatchupAnalysis(stationsForAnalysis, metric);
                
                let analysisHtml = '';
                if (bestDealStats) analysisHtml += renderBestDealSection(bestDealStats, metric);
                if (priceStats) analysisHtml += renderPriceStatisticsSection(priceStats, metric);
                if (bucketStats) analysisHtml += renderBucketSection(bucketStats, metric, providerTotals);
                if (matchupStats) analysisHtml += renderMatchupAnalysisSection(matchupStats);

                infoContent.innerHTML = analysisHtml;
                infoPlaceholder.classList.add('hidden');
                infoContent.classList.remove('hidden');
                attachSidebarEventListeners();
            }
            
            function calculateMedian(arr) {
                if (!arr || arr.length === 0) return 'N/A';
                const sortedArr = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sortedArr.length / 2);
                return sortedArr.length % 2 !== 0 ? sortedArr[mid] : (sortedArr[mid - 1] + sortedArr[mid]) / 2;
            }

            function calculateBestDealStats(allStations, metric, filter = 'all') {
    const providerCount = Object.keys(state.stationData).length;
    if (providerCount < 2) return null;

    const isHigherBetter = metric === 'savings';
    const wins = {};
    Object.keys(state.stationData).forEach(p => wins[p] = 0);
    const processedGroups = new Set();
    
    const stationsToCheck = allStations.filter(s => s.isPaired || s.isTriadPaired || s.isTetradPaired);

    const findWinner = (group) => {
        if (group.length === 0) return null;
        let winner = group[0];
        let bestValue = winner[metric];
        if (isNaN(bestValue)) {
            bestValue = isHigherBetter ? 0 : winner.retail;
        }

        for (let i = 1; i < group.length; i++) {
            const competitor = group[i];
            let competitorValue = competitor[metric];
            if (isNaN(competitorValue)) {
                competitorValue = isHigherBetter ? 0 : competitor.retail;
            }
            
            if ((isHigherBetter && competitorValue > bestValue) || (!isHigherBetter && competitorValue < bestValue)) {
                bestValue = competitorValue;
                winner = competitor;
            }
        }
        return winner;
    };

    for (const station of stationsToCheck) {
        // --- NEW: Tetrad Win Calculation ---
        if ((filter === 'all' || filter === 'tetrads') && station.isTetradPaired && station.tetrads) {
            station.tetrads.forEach(partners => {
                const competitorGroup = [station, ...partners];
                const groupKey = competitorGroup.map(s => s.id).sort().join('|');
                if (!processedGroups.has(groupKey)) {
                    const winner = findWinner(competitorGroup);
                    if (winner) wins[winner.provider]++;
                    processedGroups.add(groupKey);
                }
            });
        }
        
        // --- Triad Win Calculation ---
        if ((filter === 'all' || filter === 'triads') && station.isTriadPaired && station.triads) {
            station.triads.forEach(partners => {
                const competitorGroup = [station, ...partners];
                const groupKey = competitorGroup.map(s => s.id).sort().join('|');
                if (!processedGroups.has(groupKey)) {
                    const winner = findWinner(competitorGroup);
                    if (winner) wins[winner.provider]++;
                    processedGroups.add(groupKey);
                }
            });
        }
        
        // --- Pair Win Calculation ---
        if ((filter === 'all' || filter === 'pairs') && station.isPaired) {
            station.competitors.forEach(competitor => {
                const competitorGroup = [station, competitor];
                const groupKey = competitorGroup.map(s => s.id).sort().join('|');
                if (!processedGroups.has(groupKey)) {
                    const winner = findWinner(competitorGroup);
                    if (winner) wins[winner.provider]++;
                    processedGroups.add(groupKey);
                }
            });
        }
    }
    
    const totalWins = Object.values(wins).reduce((a, b) => a + b, 0);
    if (totalWins === 0) return null;

    const results = Object.entries(wins).map(([provider, count]) => ({
        provider,
        count,
        percentage: (count / totalWins) * 100
    })).sort((a, b) => b.count - a.count);

    return { results, total: totalWins };
}

            

            function calculatePriceStatistics(allStations, metric) {
                const stats = {};
                const isSavings = metric === 'savings';
                Object.keys(state.stationData).forEach(provider => {
                    const prices = allStations
                        .filter(s => s.provider === provider)
                        .map(s => {
                            let value = s[metric];
                            if (isNaN(value)) value = isSavings ? 0 : s.retail;
                            return value;
                        })
                        .filter(p => !(isSavings && p === 0) && !isNaN(p))
                        .sort((a, b) => a - b);
                    
                    if (prices.length === 0) {
                        stats[provider] = { avg: 'N/A', median: 'N/A', percentile70: 'N/A' };
                        return;
                    };
                    
                    const sum = prices.reduce((a, b) => a + b, 0);
                    stats[provider] = {
                        avg: sum / prices.length,
                        median: prices.length % 2 === 0 ? (prices[prices.length/2-1] + prices[prices.length/2]) / 2 : prices[Math.floor(prices.length/2)],
                        percentile70: prices[Math.floor(prices.length * 0.7)]
                    };
                });
                return Object.keys(stats).length > 0 ? stats : null;
            }

            function calculateBucketCounts(allStations, metric) {
                const isSavings = metric === 'savings';
                const validValues = allStations
                    .map(s => {
                        let value = s[metric];
                        if (isNaN(value)) value = isSavings ? 0 : s.retail;
                        return value;
                    })
                    .filter(p => !(isSavings && p === 0) && !isNaN(p));

                if (validValues.length === 0) return null;
                
                const minPrice = Math.floor(Math.min(...validValues) * 10) / 10;
                const maxPrice = Math.ceil(Math.max(...validValues) * 10) / 10;
                const increment = metric === 'savings' ? 0.05 : 0.1;
                
                const buckets = {};
                for (let p = minPrice; p <= maxPrice; p += increment) {
                    buckets[p.toFixed(2)] = Object.fromEntries(Object.keys(state.stationData).map(prov => [prov, 0]));
                }

                allStations.forEach(s => {
                    let value = s[metric];
                    if (isNaN(value)) value = isSavings ? 0 : s.retail;
                    if (isNaN(value) || (isSavings && value === 0)) return;

                    const bucketKey = (Math.floor(value / increment) * increment).toFixed(2);
                    if (buckets[bucketKey]) {
                        buckets[bucketKey][s.provider]++;
                    }
                });
                
                const maxCountInBucket = Math.max(0, ...Object.values(buckets).map(b => Math.max(...Object.values(b))));
                return { buckets, maxCountInBucket };
            }

            function calculateMatchupAnalysis(allCompetitiveStations, metric) {
                const providerNames = Object.keys(state.stationData).sort();
                if (providerNames.length < 2) return null;

                const matchups = {};
                const processedGroups = new Set();
                
                // Use 'retail' if selected, otherwise default to 'discounted' price.
                const comparisonMetric = (metric === 'retail') ? 'retail' : 'discounted';

                const findWinner = (group) => {
                    if (group.length < 2) return { winner: null, losers: [] };
                    let winner = group[0];
                    let bestValue = winner[comparisonMetric];

                    for (let i = 1; i < group.length; i++) {
                        const competitor = group[i];
                        if (competitor[comparisonMetric] < bestValue) {
                            bestValue = competitor[comparisonMetric];
                            winner = competitor;
                        }
                    }
                    const losers = group.filter(s => s.id !== winner.id);
                    return { winner, losers };
                };

                const addMatchup = (winner, losers) => {
                    if (!winner || losers.length === 0) return;
                    const opponentKey = losers.map(l => l.provider).sort().join(',');
                    const matchupKey = `${winner.provider}>${opponentKey}`;
                    if (!matchups[matchupKey]) {
                        matchups[matchupKey] = { count: 0, prices: {} };
                        providerNames.forEach(p => matchups[matchupKey].prices[p] = []);
                    }
                    matchups[matchupKey].count++;
                    matchups[matchupKey].prices[winner.provider].push(winner.discounted);
                    losers.forEach(loser => {
                        matchups[matchupKey].prices[loser.provider].push(loser.discounted);
                    });
                };

                if (state.competitiveFilter === 'triads') {
                    allCompetitiveStations.forEach(station => {
                        if (station.isTriadPaired && station.triads.length > 0) {
                            station.triads.forEach(partners => {
                                const group = [station, ...partners];
                                const groupKey = group.map(s => s.id).sort().join('|');
                                if (processedGroups.has(groupKey)) return;
                                processedGroups.add(groupKey);

                                const { winner: overallWinner, losers: overallLosers } = findWinner(group);
                                addMatchup(overallWinner, overallLosers);

                                const [s1, s2, s3] = group;
                                const { winner: w12, losers: l12 } = findWinner([s1, s2]);
                                addMatchup(w12, l12);
                                
                                const { winner: w13, losers: l13 } = findWinner([s1, s3]);
                                addMatchup(w13, l13);

                                const { winner: w23, losers: l23 } = findWinner([s2, s3]);
                                addMatchup(w23, l23);
                            });
                        }
                    });
                } else {
                    allCompetitiveStations.forEach(station => {
                        if (station.isTriadPaired && station.triads.length > 0) {
                            station.triads.forEach(partners => {
                                const group = [station, ...partners];
                                const groupKey = group.map(s => s.id).sort().join('|');
                                if (processedGroups.has(groupKey)) return;
                                processedGroups.add(groupKey);
                                const { winner, losers } = findWinner(group);
                                addMatchup(winner, losers);
                            });
                        }
                        
                        if (station.isPaired && station.competitors.length > 0) {
                            station.competitors.forEach(competitor => {
                                const group = [station, competitor];
                                const groupKey = group.map(s => s.id).sort().join('|');
                                if (processedGroups.has(groupKey)) return;
                                processedGroups.add(groupKey);
                                const { winner, losers } = findWinner(group);
                                addMatchup(winner, losers);
                            });
                        }
                    });
                }

                const results = [];
                for (const key in matchups) {
                    const [winner, opponentsStr] = key.split('>');
                    const opponents = opponentsStr.split(',');
                    const data = matchups[key];
                    if (data.count === 0) continue;

                    const row = { winner, opponents, count: data.count, medianPrices: {} };
                    for (const provider in data.prices) {
                        if (data.prices[provider].length > 0) {
                            row.medianPrices[provider] = calculateMedian(data.prices[provider]);
                        }
                    }
                    results.push(row);
                }
                
                return results;
            }

            function renderBestDealSection(stats, metric) {
                const metricMap = { discounted: 'Best Deal', retail: 'Best Retail Deal', savings: 'Best Savings' };
                const title = metricMap[metric] || 'Best Deal';
                
                let gradientStops = [];
                let currentPercentage = 0;
                stats.results.forEach(r => {
                    const color = providerColors[r.provider] || '#6b7280';
                    gradientStops.push(`${color} ${currentPercentage}% ${currentPercentage + r.percentage}%`);
                    currentPercentage += r.percentage;
                });
                
                const tableRows = stats.results.map(r => `
                    <tr class="border-b border-gray-700/50 text-xs">
                        <td class="py-1.5 px-2 flex items-center"><span class="w-2 h-2 rounded-full mr-2" style="background-color: ${providerColors[r.provider] || '#6b7280'};"></span>${r.provider}</td>
                        <td class="py-1.5 px-2 text-right font-mono">${r.count}</td>
                        <td class="py-1.5 px-2 text-right font-mono">${r.percentage.toFixed(0)}%</td>
                    </tr>`).join('');

                return `
                    <div class="bg-gray-800 p-2 rounded-lg">
                        <h3 class="font-bold text-sm text-blue-400 mb-2">${title} in Competitive Zones (${stats.total} total)</h3>
                        <div class="flex items-center space-x-3">
                            <div class="w-16 h-16 rounded-full" style="background: conic-gradient(${gradientStops.join(', ')});"></div>
                            <div class="flex-grow">
                                <table class="w-full">
                                    <thead class="text-xs text-white uppercase"><tr class="bg-gray-900 border-b border-gray-700"><th class="py-1.5 px-2 font-semibold text-left">Provider</th><th class="py-1.5 px-2 font-semibold text-right"># Wins</th><th class="py-1.5 px-2 font-semibold text-right">% Wins</th></tr></thead>
                                    <tbody>${tableRows}</tbody>
                                </table>
                            </div>
                        </div>
                    </div>`;
            }

            function renderPriceStatisticsSection(stats, metric) {
                const metricMap = { discounted: 'Discounted Price', retail: 'Retail Price', savings: 'Savings' };
                const title = `${metricMap[metric]} Statistics`;
                const prefix = metric === 'savings' ? '' : '$';

                const rows = Object.entries(stats).map(([provider, data]) => {
                    const avgText = typeof data.avg === 'number' ? `${prefix}${data.avg.toFixed(2)}` : data.avg;
                    const medianText = typeof data.median === 'number' ? `${prefix}${data.median.toFixed(2)}` : data.median;
                    const p70Text = typeof data.percentile70 === 'number' ? `${prefix}${data.percentile70.toFixed(2)}` : data.percentile70;

                    return `
                    <tr class="border-b border-gray-700/50 text-xs">
                        <td class="py-1.5 px-2 font-semibold" style="color: ${providerColors[provider] || '#FFF'};">${provider}</td>
                        <td class="py-1.5 px-2 text-right font-mono">${avgText}</td>
                        <td class="py-1.5 px-2 text-right font-mono">${medianText}</td>
                        <td class="py-1.5 px-2 text-right font-mono">${p70Text}</td>
                    </tr>`
                }).join('');

                return `
                    <div class="bg-gray-800 p-2 rounded-lg">
                        <div class="flex items-center space-x-2 mb-2">
                            <h3 class="font-bold text-sm text-blue-400">${title} by Provider</h3>
                            ${metric === 'savings' ? `
                                <div class="relative group cursor-pointer">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-48 bg-gray-900 text-gray-300 text-xs text-center rounded-md p-2 border border-gray-600 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-10">
                                        Stations with $0.00 (no discount) are excluded from this calculation.
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <table class="w-full">
                           <thead class="text-xs text-white uppercase"><tr class="bg-gray-900 border-b border-gray-700"><th class="py-1.5 px-2 font-semibold text-left">Provider</th><th class="py-1.5 px-2 font-semibold text-right">Average</th><th class="py-1.5 px-2 font-semibold text-right">Median</th><th class="py-1.5 px-2 font-semibold text-right">70%-ile</th></tr></thead>
                           <tbody>${rows}</tbody>
                        </table>
                    </div>`;
            }

            function renderBucketSection(stats, metric, providerTotals) {
                const providers = Object.keys(state.stationData);
                const metricMap = { discounted: 'Discounted Price', retail: 'Retail Price', savings: 'Savings' };
                const title = `${metricMap[metric]} Distribution`;
                const prefix = metric === 'savings' ? '' : '$';

                const filteredBuckets = Object.entries(stats.buckets).filter(([_, counts]) => Object.values(counts).some(c => c > 0));

                const tableRows = filteredBuckets.map(([bucket, counts]) => {
                    const maxCountInRow = Math.max(0, ...Object.values(counts));
                    return `
                    <tr class="text-xs border-b border-gray-700/50">
                        <td class="py-1.5 px-2 font-mono text-gray-300">${prefix}${bucket}</td>
                        ${providers.map(p => {
                            const count = counts[p];
                            const total = providerTotals[p] || 0;
                            const percentage = total > 0 ? (count / total) * 100 : 0;
                            const percentageText = count > 0 ? ` <span class="text-gray-500 font-normal">(${percentage.toFixed(0)}%)</span>` : '';
                            const maxClass = (count === maxCountInRow && maxCountInRow > 0) ? 'font-bold' : '';
                            const colorClass = count > 0 ? 'text-white' : 'text-gray-600';
                            return `<td class="py-1.5 px-2 text-right font-mono ${colorClass} ${maxClass}">${count}${percentageText}</td>`;
                        }).join('')}
                    </tr>`;
                }).join('');
                
                const chartBars = filteredBuckets.map(([bucket, counts]) => {
                    const allCountsString = JSON.stringify(counts);
                    const barSegments = providers.map(p => {
                        const height = stats.maxCountInBucket > 0 ? (counts[p] / stats.maxCountInBucket) * 100 : 0;
                        return `<div class="w-full" style="height: ${height}%; background-color: ${providerColors[p]};"></div>`;
                    }).join('');
                    return `<div class="w-4 h-24 flex flex-col-reverse items-center chart-bar-column" 
                                 data-bucket-value="${prefix}${bucket}"
                                 data-metric-name="${metricMap[metric]}"
                                 data-all-counts='${allCountsString}'>${barSegments}</div>`;
                }).join('');

                const legendItems = providers.map(p => `
                    <div class="flex items-center"><span class="w-2.5 h-2.5 rounded-full mr-1.5" style="background-color: ${providerColors[p] || '#6b7280'};"></span>${p}</div>`).join('');

                return `
                    <div class="bg-gray-800 p-2 rounded-lg">
                        <div class="flex justify-between items-center mb-2">
                            <div class="flex items-center space-x-2">
                                <h3 class="font-bold text-sm text-blue-400">${title} by Bucket</h3>
                                ${metric === 'savings' ? `
                                    <div class="relative group cursor-pointer">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-48 bg-gray-900 text-gray-300 text-xs text-center rounded-md p-2 border border-gray-600 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-10">
                                            Stations with $0.00 (no discount) are excluded from this calculation.
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                            <div class="flex space-x-1 text-xs">
                                <button id="show-table-btn" class="bg-blue-600 px-2 py-0.5 rounded-md">Table</button>
                                <button id="show-chart-btn" class="bg-gray-700 px-2 py-0.5 rounded-md">Chart</button>
                            </div>
                        </div>
                        <div id="bucket-table-container">
                             <div class="h-64 overflow-y-auto custom-scrollbar">
                                <table class="w-full">
                                    <thead><tr class="text-left text-xs text-white sticky top-0 bg-gray-900 border-b border-gray-700"><th class="py-1.5 px-2 font-semibold">Bucket</th>${providers.map(p => `<th class="py-1.5 px-2 text-right font-semibold" style="color:${providerColors[p] || '#FFF'}">${p}</th>`).join('')}</tr></thead>
                                    <tbody>${tableRows}</tbody>
                                </table>
                            </div>
                        </div>
                        <div id="bucket-chart-container" class="hidden">
                            <div class="flex justify-center space-x-4 text-xs text-gray-400 mb-2">${legendItems}</div>
                            <div class="flex space-x-1 items-end bg-gray-900/50 p-1 rounded-md overflow-x-auto custom-scrollbar h-40">${chartBars}</div>
                        </div>
                    </div>`;
            }

            function renderMatchupAnalysisSection(stats) {
                if (!stats || stats.length === 0) return '';
                
                const providerNames = Object.keys(state.stationData).sort();

                stats.sort((a, b) => {
                    if (b.opponents.length !== a.opponents.length) {
                        return b.opponents.length - a.opponents.length;
                    }
                    return b.count - a.count;
                });

                const header = `
                    <tr class="text-left text-xs text-white sticky top-0 bg-gray-900 border-b border-gray-700">
                        <th class="py-1.5 px-2 font-semibold">When Winner</th>
                        <th class="py-1.5 px-2 font-semibold">Compared Against</th>
                        ${providerNames.map(p => `<th class="py-1.5 px-2 text-right font-semibold" style="color: ${providerColors[p] || '#FFF'};">${p} Price</th>`).join('')}
                        <th class="py-1.5 px-2 text-right font-semibold">Count</th>
                    </tr>
                `;

                const rows = stats.map(row => {
                    return `
                        <tr class="text-xs border-b border-gray-700/50">
                            <td class="py-1.5 px-2">${row.winner}</td>
                            <td class="py-1.5 px-2">${row.opponents.join(', ')}</td>
                            ${providerNames.map(p => {
                                const price = row.medianPrices[p];
                                return `<td class="py-1.5 px-2 text-right font-mono">${typeof price === 'number' ? `$${price.toFixed(2)}` : ''}</td>`;
                            }).join('')}
                            <td class="py-1.5 px-2 text-right font-mono">${row.count.toLocaleString()}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div class="bg-gray-800 p-2 rounded-lg">
                        <h3 class="font-bold text-sm text-blue-400 mb-2">Competitive Matchup Analysis</h3>
                        <div class="h-64 overflow-y-auto custom-scrollbar">
                            <table class="w-full">
                                <thead>${header}</thead>
                                <tbody>${rows}</tbody>
                            </table>
                        </div>
                    </div>
                `;
            }

            function attachSwitcherListeners() {
                document.querySelectorAll('#competitive-filter-switcher .filter-btn').forEach(btn => {
                    if (btn.dataset.listenerAttached) return;
                    btn.addEventListener('click', (e) => {
                        const newFilter = e.currentTarget.dataset.filter;
                        state.competitiveFilter = newFilter;
                        updateMapAndUI();
                    });
                    btn.dataset.listenerAttached = 'true';
                });
            }

            function attachSidebarEventListeners() {
                attachSwitcherListeners();

                const showTableBtn = document.getElementById('show-table-btn');
                const showChartBtn = document.getElementById('show-chart-btn');
                const tableContainer = document.getElementById('bucket-table-container');
                const chartContainer = document.getElementById('bucket-chart-container');

                if (showTableBtn) {
                    showTableBtn.addEventListener('click', () => {
                        tableContainer.classList.remove('hidden');
                        chartContainer.classList.add('hidden');
                        showTableBtn.classList.replace('bg-gray-700', 'bg-blue-600');
                        showChartBtn.classList.replace('bg-blue-600', 'bg-gray-700');
                    });
                }
                if (showChartBtn) {
                    showChartBtn.addEventListener('click', () => {
                        tableContainer.classList.add('hidden');
                        chartContainer.classList.remove('hidden');
                        showChartBtn.classList.replace('bg-gray-700', 'bg-blue-600');
                        showTableBtn.classList.replace('bg-blue-600', 'bg-gray-700');
                    });
                }

                const tooltip = document.getElementById('chart-tooltip');
                document.querySelectorAll('.chart-bar-column').forEach(bar => {
                    bar.addEventListener('mouseover', (e) => {
                        const data = e.currentTarget.dataset;
                        const allCounts = JSON.parse(data.allCounts);
                        const providerColors = { 'Pilot Flying J': '#2563eb', 'Bobtail': '#dc2626', 'TA': '#16a34a', 'Mudflap': '#f97316', 'Other': '#6b7280' };

                        let tooltipContent = `<div class="font-semibold mb-1">${data.metricName}: ${data.bucketValue}</div>`;
                        tooltipContent += Object.entries(allCounts).map(([provider, count]) => {
                            if (count > 0) {
                                return `<div class="flex items-center"><span class="w-2 h-2 rounded-full mr-2" style="background-color: ${providerColors[provider] || '#6b7280'};"></span>${provider}: ${count}</div>`;
                            }
                            return '';
                        }).join('');

                        tooltip.innerHTML = tooltipContent;
                        tooltip.classList.remove('hidden');
                    });

                    bar.addEventListener('mousemove', (e) => {
                        tooltip.style.left = `${e.clientX + 15}px`;
                        tooltip.style.top = `${e.clientY + 15}px`;
                    });

                    bar.addEventListener('mouseleave', () => {
                        tooltip.classList.add('hidden');
                    });
                });
            }

            // --- CONTROLS & EVENT LISTENERS ---
            document.getElementById('analysis-metric-select').addEventListener('change', (e) => {
    state.analysisMetric = e.target.value;
    updateMapAndUI();
});

// --- Custom State Dropdown Logic ---
const stateInput = document.getElementById('state-input');
const statePanel = document.getElementById('state-dropdown-panel');
const stateContainer = document.getElementById('state-dropdown-container');

// Show dropdown on click
stateInput.addEventListener('click', (e) => {
    e.stopPropagation();
    updateStateSelector(stateInput.value); // Re-populate with current filter
    statePanel.classList.toggle('hidden');
});

// Filter list as user types
stateInput.addEventListener('input', () => {
    updateStateSelector(stateInput.value);
    statePanel.classList.remove('hidden'); // Ensure panel is visible while typing
});

// If input is cleared, reset to all states
stateInput.addEventListener('change', () => {
    if (stateInput.value === '') {
        state.selectedState = 'all';
        updateMapAndUI();
        map.setView([39.8283, -98.5795], 5);
    }
});

// Hide dropdown when clicking anywhere else on the page
document.addEventListener('click', (e) => {
    if (!stateContainer.contains(e.target)) {
        statePanel.classList.add('hidden');
        // Revert input to last valid selection if it wasn't confirmed
        if (state.selectedState === 'all') {
            stateInput.value = '';
        } else {
            stateInput.value = state.selectedState;
        }
    }
});

radiusSlider.addEventListener('change', (e) => {
    let radius = parseInt(e.target.value);
    if (isNaN(radius) || radius < 1) {
        radius = 1; 
        e.target.value = radius;
    }
    state.clusterRadius = radius;
    updateMapAndUI();
});
            
            hideCheckbox.addEventListener('change', (e) => {
                state.hideUnclustered = e.target.checked;
                applyVisibilityFilter();
            });
            
            showTriadsCheckbox.addEventListener('change', (e) => {
                state.showTriadsOnly = e.target.checked;
                // If turning on Triads, turn off Tetrads
                if (e.target.checked && state.showTetradsOnly) {
                    state.showTetradsOnly = false;
                    document.getElementById('show-tetrads-only').checked = false;
                }
                applyVisibilityFilter();
            });

            // New listener for the Tetrads checkbox
            document.getElementById('show-tetrads-only').addEventListener('change', (e) => {
                state.showTetradsOnly = e.target.checked;
                // If turning on Tetrads, turn off Triads
                if (e.target.checked && state.showTriadsOnly) {
                    state.showTriadsOnly = false;
                    document.getElementById('show-triads-only').checked = false;
                }
                applyVisibilityFilter();
            });

            function updateLineVisibility() {
                if (!state.showLines) {
                    if (map.hasLayer(state.linesLayer)) {
                        map.removeLayer(state.linesLayer);
                    }
                    return;
                }

                if (map.getZoom() >= 9) {
                    if (!map.hasLayer(state.linesLayer)) {
                        map.addLayer(state.linesLayer);
                    }
                } else {
                    if (map.hasLayer(state.linesLayer)) {
                        map.removeLayer(state.linesLayer);
                    }
                }
            }

        map.on('zoomend', updateLineVisibility);

        function applyVisibilityFilter() {
                state.markers.clearLayers();
                const visibleMarkers = allMarkers.filter(marker => {
                    const s = marker.stationData;
                    if (state.showTetradsOnly) return s.isTetradPaired;
                    if (state.showTriadsOnly) return s.isTriadPaired;
                    if (state.hideUnclustered) return s.isPaired || s.isTriadPaired || s.isTetradPaired;
                    return true;
                });
                state.markers.addLayers(visibleMarkers);

                state.linesLayer.clearLayers();
                
                const drawnLinks = new Set();
                const currentOpacity = state.lineOpacity;
                const fillOpacity = Math.max(0.05, currentOpacity * 0.15); 

                allMarkers.forEach(marker => {
                    const station = marker.stationData;

                    if (station.isTetradPaired && station.tetrads.length > 0) {
                         station.tetrads.forEach(partners => {
                            const ids = [station.id, partners[0].id, partners[1].id, partners[2].id].sort().join('-');
                             if (!drawnLinks.has(ids)) {
                                // --- Fix for drawing a reliable 4-sided polygon ---
                                const allPoints = [station, ...partners];
                                
                                // 1. Calculate the geometric center (centroid) of the 4 points.
                                let totalLat = 0, totalLon = 0;
                                allPoints.forEach(p => { totalLat += p.lat; totalLon += p.lon; });
                                const centerLat = totalLat / 4;
                                const centerLon = totalLon / 4;
                                
                                // 2. Sort the points by their angle around the center.
                                allPoints.sort((a, b) => {
                                    const angleA = Math.atan2(a.lat - centerLat, a.lon - centerLon);
                                    const angleB = Math.atan2(b.lat - centerLat, b.lon - centerLon);
                                    return angleA - angleB;
                                });

                                // 3. Create the ordered array of coordinates for the polygon.
                                const sortedCoords = allPoints.map(p => [p.lat, p.lon]);
                                
                                // 4. Draw the polygon with the sorted points and new blue color.
                                L.polygon(sortedCoords, { color: '#3b82f6', weight: 2, opacity: currentOpacity, fillOpacity: fillOpacity }).addTo(state.linesLayer);
                                drawnLinks.add(ids);
                            }
                        });
                    }
                    
                    if (station.isTriadPaired && !state.showTetradsOnly && station.triads.length > 0) {
                        station.triads.forEach(partners => {
                            const ids = [station.id, partners[0].id, partners[1].id].sort().join('-');
                            if (!drawnLinks.has(ids)) {
                                const points = [ [station.lat, station.lon], [partners[0].lat, partners[0].lon], [partners[1].lat, partners[1].lon] ];
                                L.polygon(points, { color: '#16a34a', weight: 2, opacity: currentOpacity, fillOpacity: fillOpacity }).addTo(state.linesLayer);
                                drawnLinks.add(ids);
                            }
                        });
                    }
                    
                    if (station.isPaired && !state.showTriadsOnly && !state.showTetradsOnly) {
                        station.competitors.forEach(competitor => {
                            const ids = [station.id, competitor.id].sort().join('-');
                            if(!drawnLinks.has(ids)) {
                                L.polyline([[station.lat, station.lon], [competitor.lat, competitor.lon]], { color: '#e74c3c', weight: 2, opacity: currentOpacity, dashArray: '5, 5' }).addTo(state.linesLayer);
                                drawnLinks.add(ids);
                            }
                        });
                    }
                });
            }

            // <--
            // --- NEW: Price Bracket Functions ---
            // -->

            /**
             * Populates the provider dropdown for the price bracket feature.
             */
            function populatePriceBracketProviders() {
                const select = document.getElementById('bracket-provider-select');
                if (!select) return;

                const currentVal = select.value;
                select.innerHTML = ''; // Clear existing
                
                const providers = Object.keys(state.stationData);

                // Add "All Providers" option
                const allOption = document.createElement('option');
                allOption.value = 'all';
                allOption.textContent = `All Providers (${Object.values(state.stationData).flat().length})`;
                select.appendChild(allOption);

                // Add individual provider options
                providers.sort().forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider;
                    option.textContent = `${provider} (${state.stationData[provider].length})`;
                    select.appendChild(option);
                });

                // Try to restore previous selection
                if (providers.includes(currentVal)) {
                    select.value = currentVal;
                } else {
                    select.value = 'all';
                }
                state.priceBracketProvider = select.value;
            }

            /**
             * Toggles visibility of marker layers based on price bracket mode.
             */
            function updatePriceBracketVisibility() {
                if (state.showPriceBrackets) {
                    // Show brackets: hide main markers, draw brackets
                    if (map.hasLayer(state.markers)) {
                        map.removeLayer(state.markers);
                    }
                    drawPriceBrackets();
                } else {
                    // Hide brackets: clear bracket layer, show main markers
                    state.priceBracketLayer.clearLayers();
                    document.getElementById('bracket-legend-container').innerHTML = '';
                    if (!map.hasLayer(state.markers)) {
                        map.addLayer(state.markers);
                    }
                }
            }

            /**
             * Calculates price brackets (quintiles) for a set of stations.
             * @returns {object} { brackets: number[], colors: string[], labels: string[], metricLabel: string }
             */
            function calculatePriceBrackets(stations, metric) {
                const metricMap = { discounted: 'Discounted', retail: 'Retail', savings: 'Savings' };
                const isSavings = metric === 'savings'; // Savings are inverted (higher is better)
                const prefix = isSavings ? '' : '$';

                // Get all valid, non-zero (for savings) prices
                const prices = stations
                    .map(s => {
                        let value = s[metric];
                        if (isNaN(value)) value = isSavings ? 0 : s.retail;
                        return value;
                    })
                    .filter(p => !(isSavings && p === 0) && !isNaN(p))
                    .sort((a, b) => a - b);
                
                if (prices.length < 5) { // Not enough data to make 5 brackets
                    return null;
                }

                // Calculate quintiles (20th, 40th, 60th, 80th percentiles)
                const p20 = prices[Math.floor(prices.length * 0.2)];
                const p40 = prices[Math.floor(prices.length * 0.4)];
                const p60 = prices[Math.floor(prices.length * 0.6)];
                const p80 = prices[Math.floor(prices.length * 0.8)];
                const min = prices[0];
                const max = prices[prices.length - 1];

             
                const counts = [0, 0, 0, 0, 0];
                prices.forEach(p => {
                    if (p <= p20) counts[0]++;
                    else if (p <= p40) counts[1]++;
                    else if (p <= p60) counts[2]++;
                    else if (p <= p80) counts[3]++;
                    else counts[4]++;
                });
               

               
                const brackets = [p20, p40, p60, p80];
                const colors = isSavings 
                    ? ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e'] 
                    : ['#22c55e', '#84cc16', '#eab308', '#f97316', '#ef4444']; 
                
               
                const labels = [
                    `${prefix}${min.toFixed(2)} - ${prefix}${p20.toFixed(2)} (Count: ${counts[0]})`,
                    `${prefix}${p20.toFixed(2)} - ${prefix}${p40.toFixed(2)} (Count: ${counts[1]})`,
                    `${prefix}${p40.toFixed(2)} - ${prefix}${p60.toFixed(2)} (Count: ${counts[2]})`,
                    `${prefix}${p60.toFixed(2)} - ${prefix}${p80.toFixed(2)} (Count: ${counts[3]})`,
                    `${prefix}${p80.toFixed(2)} - ${prefix}${max.toFixed(2)} (Count: ${counts[4]})`
                ];
                

                return { brackets, colors, labels, metricLabel: metricMap[metric] };
            }

            /**
             * Gets the bracket index (0-4) for a given price.
             */
            function getBracketForPrice(price, brackets) {
                if (price <= brackets[0]) return 0;
                if (price <= brackets[1]) return 1;
                if (price <= brackets[2]) return 2;
                if (price <= brackets[3]) return 3;
                return 4;
            }

            /**
             * Clears and redraws all markers on the price bracket layer.
             */
            function drawPriceBrackets() {
                state.priceBracketLayer.clearLayers();
                const legendContainer = document.getElementById('bracket-legend-container');
                legendContainer.innerHTML = '';

                const { selectedState, priceBracketProvider, analysisMetric } = state;

                // 1. Get all stations (raw)
                const allStationsRaw = Object.values(state.stationData).flat();
                if (allStationsRaw.length === 0) return;

                // 2. Filter by selected state
                let stationsForAnalysis = (selectedState === 'all')
                    ? allStationsRaw
                    : allStationsRaw.filter(s => s.state === selectedState);

                // 3. Filter by selected provider
                if (priceBracketProvider !== 'all') {
                    stationsForAnalysis = stationsForAnalysis.filter(s => s.provider === priceBracketProvider);
                }

                if (stationsForAnalysis.length === 0) {
                     legendContainer.innerHTML = '<p>No stations found for this filter.</p>';
                     return;
                }

                // 4. Calculate brackets
                const bracketData = calculatePriceBrackets(stationsForAnalysis, analysisMetric);

                if (!bracketData) {
                    legendContainer.innerHTML = '<p>Not enough data to generate brackets.</p>';
                    return;
                }

                const { brackets, colors, labels, metricLabel } = bracketData;
                const isSavings = analysisMetric === 'savings';

                // 5. Draw Legend
                legendContainer.innerHTML = `<p class="font-semibold text-gray-100 mb-1">${metricLabel} Brackets</p>`;
                labels.forEach((label, i) => {
                    legendContainer.innerHTML += `
                        <div class="flex items-center space-x-2">
                            <span class="w-3 h-3 rounded-full" style="background-color: ${colors[i]}; border: 1px solid #9ca3af;"></span>
                            <span>${label}</span>
                        </div>
                    `;
                });

                // 6. Draw Markers
                stationsForAnalysis.forEach(station => {
                    let price = station[analysisMetric];
                    if (isNaN(price)) price = isSavings ? 0 : station.retail;
                    if (isNaN(price) || (isSavings && price === 0)) return; // Skip invalid

                    const bracketIndex = getBracketForPrice(price, brackets);
                    const color = colors[bracketIndex];

                    const circle = L.circleMarker([station.lat, station.lon], {
                        radius: 4, // <-- Made smaller (was 5)
                        fillColor: color, // <-- Fill is the bracket color
                        fillOpacity: 0.3, // <-- Set to 30% opacity
                        color: color, // <-- Outline is the bracket color
                        weight: 1, // <-- Made outline thinner (was 2)
                        opacity: 0.7, // <-- Made outline semi-transparent (was 1)
                    });

                    const popupContent = createStationPopupContent(station);
                    circle.bindPopup(popupContent);
                    circle.addTo(state.priceBracketLayer);
                });
            }

            // --- END of Price Bracket Functions ---


            // --- Initial Load ---
            updateProviderList();
            renderAnalysisSidebar([]);
            populatePriceBracketProviders(); // <-- NEW: Populate dropdown on load
        });
    </script>
</body>
</html>
